<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Tactical Ascension (SapphLib)</title>
<style>
/* Constrain the lists and enable scrolling */
#upgrade-list, #shop-list {
    max-height: 420px; /* Limits height to fit roughly 5-6 items at a time */
    overflow-y: auto;
    padding-right: 10px;
    margin: 15px 0;
    border-top: 1px solid #222;
    border-bottom: 1px solid #222;
}

/* Themed Scrollbar for Chrome/Edge/Safari */
#upgrade-list::-webkit-scrollbar, 
#shop-list::-webkit-scrollbar {
    width: 6px;
}

#upgrade-list::-webkit-scrollbar-track, 
#shop-list::-webkit-scrollbar-track {
    background: #0a0a0a;
}

#upgrade-list::-webkit-scrollbar-thumb, 
#shop-list::-webkit-scrollbar-thumb {
    background: #333;
    border-radius: 3px;
}

#upgrade-list::-webkit-scrollbar-thumb:hover {
    background: var(--upgrade);
}

#shop-list::-webkit-scrollbar-thumb:hover {
    background: var(--shop);
}

/* Ensure menus don't jump when scrollbar appears */
#upgrade-menu, #shop-menu {
    max-height: 90vh; /* Prevents menu from going off-screen */
    display: none; 
    flex-direction: column;
}

  :root { --ui-bg: rgba(0,0,0,0.95); --ui-border:#444; --accent:#ECFF0C; --shield:#00ccff; --powerup:#ff00ff; --upgrade:#00ff88; --shop: #ffcc00; }
  html,body{height:100%}
  body{
    margin:0;padding:0;overflow:hidden;background:#050505;color:#fff;
    font-family: "Courier New", monospace;
    transition: background 0.5s ease;
    user-select: none;
  }
  canvas{display:block; background: transparent;}
  #ui,#menu,#game-over,#victory,#settings,#sandbox-ui,#upgrade-menu,#shop-menu,#perk-menu{position:absolute;text-shadow:2px 2px #000}
  #ui{top:18px;left:18px;width:380px;pointer-events:none}
#sandbox-ui {
top: 18px; right: 18px; width: 220px; background: var(--ui-bg);
border: 1px solid var(--accent); padding: 15px; display: none; z-index: 1000;
}
.sandbox-label { font-size: 10px; color: var(--accent); margin-bottom: 4px; letter-spacing: 1px; }
#player-hp {margin-top:6px;font-size:14px}
.hp-bar {width:240px;height:12px;background:#111;border:1px solid #333;display:inline-block;vertical-align:middle}
.hp-fill {height:100%;background:#ff4d4d;width:100%;transition: width 0.1s;}
.shield-fill {height:100%;background:var(--shield);width:100%;transition: width 0.1s;}
.ability-slot{display:inline-block;width:120px;margin-right:10px}
.cooldown-bg{width:100%;height:7px;background:#333;border:1px solid #555;margin-top:4px}
.cooldown-fill{height:100%;background:#00ffff;width:100%}
.muted{color:#888;font-size:12px}
#timer-container{position:absolute;top:18px;right:18px;font-size:20px;color:#00ff00;display:none}
#boss-ui{position:absolute;top:68px;left:50%;transform:translateX(-50%);width:60%;display:none}
#boss-bar-bg{width:100%;height:12px;background:#222;border:1px solid #fff}
#boss-bar-fill{width:100%;height:100%;background:#ff0000;transition:width .2s}
#menu,#game-over,#victory,#upgrade-menu,#shop-menu{top:50%;left:50%;transform:translate(-50%,-50%);text-align:center;background:var(--ui-bg);padding:26px;border:1px solid var(--ui-border);width:700px;z-index:1000}
#upgrade-menu { display: none; width: 500px; border-color: var(--upgrade); }
#shop-menu { display: none; width: 600px; border-color: var(--shop); }
/* PERK MENU STYLES */
#perk-menu {
display:none; top:50%; left:50%; transform:translate(-50%,-50%); width:650px;
background:var(--ui-bg); border:2px solid var(--accent); padding:30px; z-index:3000;
text-align:center; box-shadow: 0 0 30px rgba(236, 255, 12, 0.2);
}
.perk-card {
flex: 1; background: #0a0a0a; border: 1px solid #333; padding: 20px; cursor: pointer; transition: all 0.2s ease;
display: flex; flex-direction: column; align-items: center; gap: 10px;
}
.perk-card:hover { border-color: var(--accent); background: #151515; transform: translateY(-5px); }
.perk-name { color: var(--accent); font-weight: bold; font-size: 14px; text-transform: uppercase; }
.perk-desc { color: #aaa; font-size: 11px; line-height: 1.5; }
.difficulty-row{display:flex;gap:8px;margin-bottom:12px}
.diff-btn{flex:1;padding:8px;background:#111;border:1px solid var(--ui-border);color:#999;cursor:pointer}
.diff-btn.active{background:#222;color:#fff;border-color:#fff}
.btn{display:block;width:100%;padding:10px;margin:6px 0;background:#111;border:1px solid var(--ui-border);cursor:pointer;color:#fff;font-size:14px}
.btn:hover{background:#fff;color:#000}
.btn.locked { color: #555; border-style: dashed; }
.btn.locked:hover { background: #222; color: #777; }
.btn.selected { border-color: var(--accent); background: #222; color: var(--accent); box-shadow: 0 0 10px rgba(236, 255, 12, 0.3); }
#crosshair{position:absolute;width:24px;height:24px;border:2px solid rgba(255,255,255,0.6);border-radius:50%;transform:translate(-50%,-50%);pointer-events:none;z-index:2000}
#crosshair::after{content:''; position:absolute; top:50%; left:50%; width:2px; height:2px; background:#fff; transform:translate(-50%,-50%)}
#reload-msg{position:absolute;bottom:20%;left:50%;transform:translateX(-50%);color:#ffcc00;display:none;font-weight:bold;font-size:24px}
#settings{top:50%;left:50%;transform:translate(-50%,-50%);width:600px;max-height:80vh;overflow-y:auto;background:var(--ui-bg);border:1px solid var(--ui-border);padding:24px;z-index:1100;display:none}
.settings-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 20px; }
.settings-group { border-bottom: 1px solid #333; padding-bottom: 10px; }
label{display:block;font-size:13px;color:#ddd;margin-bottom:6px; display: flex; align-items: center; justify-content: space-between;}
input[type="range"] { width: 100px; accent-color: var(--accent); }
input[type="checkbox"] { width: 18px; height: 18px; cursor: pointer; }
select { background: #111; color: #fff; border: 1px solid #444; padding: 4px; width: 100%; }
#combo-ui { position: absolute; bottom: 18px; right: 18px; text-align: right; pointer-events: none; }
#combo-count { font-size: 48px; color: var(--accent); font-weight: bold; margin: 0; }
#combo-label { font-size: 14px; color: #aaa; margin: 0; }
#combo-bonus-msg { font-size: 12px; color: #00ff00; margin: 0; opacity: 0; transition: opacity 0.3s; }
.weapon-grid { display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 8px; margin-bottom: 8px; }
#level-banner { position: absolute; top: 20%; left: 50%; transform: translate(-50%, -50%); font-size: 42px; color: var(--accent); font-weight: bold; display: none; z-index: 500; text-align: center; }
#credits-display { color: var(--accent); font-weight: bold; margin-bottom: 10px; font-size: 18px; }
#xp-bar-container { position: absolute; bottom: 0; left: 0; width: 100%; height: 4px; background: #111; }
#xp-fill { height: 100%; background: #ecff0c; width: 0%; transition: width 0.3s; }
#powerup-msg { position: absolute; bottom: 100px; left: 50%; transform: translateX(-50%); color: var(--powerup); font-weight: bold; font-size: 20px; display: none; }
.upgrade-card, .shop-card { background: #111; border: 1px solid #444; padding: 10px; margin: 5px 0; text-align: left; display: flex; justify-content: space-between; align-items: center; }
.upgrade-info, .shop-info { font-size: 12px; color: #ccc; }
.upgrade-lvl { color: var(--upgrade); font-weight: bold; }
.shop-price { color: var(--shop); font-weight: bold; }
#shop-list { max-height: 400px; overflow-y: auto; padding-right: 5px; }
.keybind-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px; font-size: 12px; }
.keybind-btn { background: #222; border: 1px solid #444; color: var(--accent); padding: 4px 8px; min-width: 60px; cursor: pointer; text-align: center; }
.keybind-btn:hover { background: #333; }
.keybind-btn.waiting { border-color: #ff0000; color: #ff0000; animation: blink 1s infinite; }
@keyframes blink { 50% { opacity: 0.5; } }
</style>
</head>
<body>
<div id="crosshair"></div>
<div id="reload-msg">RELOADING...</div>
<div id="level-banner">LEVEL 1</div>
<div id="powerup-msg">OVERDRIVE ACTIVE</div>
<div id="xp-bar-container"><div id="xp-fill"></div></div>
<div id="menu">
  <h1 style="letter-spacing:8px">Tactical Ascension (SapphLib)</h1>
  <p style="color:#aaa;font-size:13px;margin-bottom:8px">DEV: ApollonGorilla | Tester: Groovy | Sapphire/SapphLib Team: Groovy, ApollonGorilla</p>
  <div id="credits-display">CREDITS: 0</div>
  <div style="font-size:12px;margin-bottom:6px;color:#aaa">DIFFICULTY</div>
  <div class="difficulty-row">
    <button class="diff-btn" id="diff-very" onclick="setDiff('very')">VERY EASY</button>
    <button class="diff-btn" id="diff-easy" onclick="setDiff('easy')">EASY</button>
    <button class="diff-btn active" id="diff-norm" onclick="setDiff('norm')">NORMAL</button>
    <button class="diff-btn" id="diff-hard" onclick="setDiff('hard')">HARD</button>
    <button class="diff-btn" id="diff-night" onclick="setDiff('night')">NIGHTMARE</button>
    <button class="diff-btn" id="diff-insane" onclick="setDiff('insane')">INSANE</button>
  </div>
  <div style="font-size:12px;margin-bottom:6px;color:var(--accent)">UNLOCKED ARSENAL</div>
  <div class="weapon-grid" id="weapon-buttons"></div>
  <div id="selected-weapon-display" style="margin-top: 15px; border-top: 1px solid #333; padding-top: 15px;">
    <div id="selected-weapon-text" style="color: var(--accent); font-size: 14px; margin-bottom: 8px; font-weight: bold;">SELECT A WEAPON TO BEGIN</div>
    <button id="play-btn" class="btn" onclick="startGame()" style="background: var(--accent); color: #000; font-weight: bold; display: none; letter-spacing: 2px;">INITIATE ASCENSION</button>
  </div>
  <div style="display: flex; gap: 10px; margin-top: 10px;">
    <button class="btn" onclick="openSettings()" style="flex: 1;">SETTINGS (P)</button>
    <button class="btn" onclick="toggleShop(true)" style="flex: 1; border-color: var(--shop); color: var(--shop);">WEAPON SHOP</button>
    <button class="btn" onclick="toggleUpgradeMenu(true)" style="flex: 1; border-color: var(--upgrade); color: var(--upgrade);">UPGRADES</button>
    <button class="btn" onclick="startSandbox()" style="flex: 1; border-color: var(--accent); color: var(--accent);">SANDBOX</button>
  </div>
</div>
<div id="perk-menu">
    <h2 style="color:var(--accent); letter-spacing:6px; margin-top:0;">RUN LEVEL <span id="perk-level-num">1</span> REACHED</h2>
    <p style="color:#888; margin-bottom:25px; font-size: 12px;">SELECT A TACTICAL AUGMENTATION</p>
    <div id="perk-choices" style="display:flex; gap:15px; justify-content:center;"></div>
</div>
<!-- SHOP MENU -->
<div id="shop-menu">
    <h2 style="color: var(--shop); letter-spacing: 4px;">BLACK MARKET ARSENAL</h2>
    <div id="shop-credits-display" style="color: var(--accent); margin-bottom: 10px;">CREDITS: 0</div>
    
    <div id="shop-list">
        <!-- Scrollable content goes here -->
    </div>
    
    <button class="btn" onclick="toggleShop(false)">BACK TO COMMAND CENTER</button>
</div>
<!-- SECRET DEV MENU -->
<div id="dev-menu" style="display:none; top:50%; left:50%; transform:translate(-50%,-50%); width:450px; background:rgba(20,0,0,0.95); border:2px solid #ff0000; padding:25px; z-index:9999; text-align:center; box-shadow: 0 0 40px rgba(255, 0, 0, 0.4); position:absolute;">
    <h2 style="color:#ff0000; letter-spacing:6px; margin-top:0;">DEVELOPER OVERRIDE</h2>
    <p style="color:#888; font-size:11px; margin-bottom:20px;">COMMANDER: APOLLONGORILLA</p>
    
    <div style="display:grid; grid-template-columns: 1fr 1fr; gap:10px;">
        <button class="btn" style="border-color:#ff0000; color:#ff0000;" onclick="credits += 50000; saveEconomy(); updateMenuUI(); playTone(1000,0.1);">+50K CREDITS</button>
        <button class="btn" style="border-color:#ff0000; color:#ff0000;" onclick="unlockedWeapons = Object.keys(WEAPONS); saveEconomy(); updateMenuUI();">UNLOCK ALL GUNS</button>
        <button id="god-mode-btn" class="btn" style="border-color:#ff0000; color:#ff0000;" onclick="toggleGodMode()">GOD MODE: OFF</button>
        <button class="btn" style="border-color:#ff0000; color:#ff0000;" onclick="enemies.length = 0; enemyAttacks.length = 0; playTone(200,0.2);">NUKE SCREEN</button>
        <button class="btn" style="border-color:#ff0000; color:#ff0000;" onclick="player.xp = player.nextXp; if(typeof handleEnemyDeath === 'function') handleEnemyDeath(-1, {dying:false});">INSTANT LEVEL</button>
        <button class="btn" style="border-color:#ff0000; color:#ff0000;" onclick="abilityState.dash.cooldown = 0; abilityState.weaponAbility.cooldown = 0; abilityState.grenade.cooldown = 0;">NO COOLDOWNS</button>
    </div>

    <button class="btn" style="margin-top:20px; border-color: #ff4d4d; color: #ff4d4d; background: rgba(255,0,0,0.1);" onclick="clearAllGameData()">CLEAR ALL SAVE DATA</button>
    <button class="btn" style="margin-top:10px; background:#400;" onclick="document.getElementById('dev-menu').style.display='none'">CLOSE CONSOLE</button>
</div>

<!-- UPGRADE MENU -->
<div id="upgrade-menu">
    <h2 style="color: var(--upgrade); letter-spacing: 4px;">SYSTEM ENHANCEMENTS</h2>
    <div id="upgrade-credits-display" style="color: var(--accent); margin-bottom: 10px;">CREDITS: 0</div>
    
    <div id="upgrade-list">
        <!-- Scrollable content goes here -->
    </div>
    
    <button class="btn" onclick="toggleUpgradeMenu(false)">BACK TO COMMAND CENTER</button>
</div>


<div id="sandbox-ui">
    <div style="font-weight: bold; margin-bottom: 10px; border-bottom: 1px solid var(--accent);">SANDBOX TOOLS</div>
    <div class="sandbox-label">SPAWN ENEMY (SHIFT+CLICK)</div>
    <select id="sandbox-enemy-select">
        <option value="normal">Normal</option>
        <option value="runner">Runner</option>
        <option value="tank">Tank</option>
        <option value="phantom">Phantom</option>
        <option value="bomber">Bomber</option>
        <option value="shooter">Shooter</option>
        <option value="splitter">Splitter</option>
        <option value="mini">Sentinel</option>
        <option value="mid">Core</option>
        <option value="final">Overseer</option>
    </select>
<div class="sandbox-label" style="margin-top: 10px;">ACTIVE WEAPON</div>
<select id="sandbox-weapon-select" onchange="changeWeapon(this.value)"></select>

<div class="sandbox-label" style="margin-top: 10px;">SPAWN DROPS</div>
<div style="display: flex; gap: 5px;">
    <button class="btn" onclick="drops.push({x:player.x+50, y:player.y, type:'ammo'})" style="font-size: 9px; padding: 5px;">AMMO</button>
    <button class="btn" onclick="drops.push({x:player.x+50, y:player.y, type:'health'})" style="font-size: 9px; padding: 5px;">HP</button>
    <button class="btn" onclick="drops.push({x:player.x+50, y:player.y, type:'powerup'})" style="font-size: 9px; padding: 5px;">BUFF</button>
</div>

<label style="margin-top: 10px; justify-content: flex-start; gap: 10px;">
    <input type="checkbox" id="sandbox-ai-toggle" checked> AI Active
</label>

<button class="btn" onclick="enemies.length = 0; enemyAttacks.length = 0; particles.length = 0;" style="font-size: 10px; margin-top: 10px;">CLEAR ALL</button>

</div>
<div id="ui" style="display:none">
  <div style="display:flex; justify-content:space-between; width: 380px;">
    <div id="mode-display" style="font-weight:bold;font-size:18px">P90</div>
    <div id="level-display" style="font-weight:bold;font-size:18px;color:var(--accent)">LEVEL 1</div>
  </div>
  <div id="difficulty-display" style="font-size:12px;color:#aaa">DIFFICULTY: NORM</div>
  <div class="muted">SECONDARY: <span id="secondary-text"></span></div>
  <div id="player-hp">
    HP: <div class="hp-bar inline"><div id="hp-fill-bar" class="hp-fill"></div></div>
    <span id="hp-text" class="muted" style="margin-left:10px">100/100</span>
  </div>
  <div id="player-shield" style="margin-top:2px">
    SH: <div class="hp-bar inline"><div id="shield-fill-bar" class="shield-fill"></div></div>
  </div>
  <div style="margin-top:8px">SCORE: <span id="score">0</span> | RUN LVL: <span id="run-lvl">1</span></div>
  <div style="font-size:14px; color:var(--accent)">CREDITS: <span id="hud-credits">0</span></div>
  <div id="ammo-ui" style="margin-top:6px">AMMO: <span id="ammo-count">50</span> / <span id="ammo-max">50</span></div>
  <div style="margin-top:8px" id="abilities">
    <div class="ability-slot">SKILL (F): <div id="skill-name" class="muted">BURST</div> <div class="cooldown-bg"><div id="cd-ability" class="cooldown-fill"></div></div></div>
    <div class="ability-slot">DASH (SPACE): <div class="cooldown-bg"><div id="cd-dash" class="cooldown-fill" style="background:#ecff0c"></div></div></div>
    <div class="ability-slot">GRENADE (G): <div class="cooldown-bg"><div id="cd-grenade" class="cooldown-fill" style="background:#ff8800"></div></div></div>
  </div>
</div>
<div id="combo-ui" style="display:none">
    <p id="combo-bonus-msg">COMBO MILESTONE! +50</p>
    <p id="combo-count">0</p>
    <p id="combo-label">COMBO</p>
</div>
<div id="boss-ui" style="display:none">
  <div id="boss-name">BOSS</div>
  <div id="boss-bar-bg"><div id="boss-bar-fill"></div></div>
</div>
<div id="timer-container" style="display:none">0.00</div>
<div id="game-over" style="display:none">
  <h1 style="color:red">SYSTEM CRASH</h1>
  <p>SCORE: <span id="final-score">0</span></p>
  <p style="color:var(--accent)">EARNED CREDITS: <span id="earned-credits-death">0</span></p>
  <button class="btn" onclick="location.reload()">REBOOT</button>
</div>
<div id="victory" style="display:none">
  <h1 style="color:gold">ASCENDED</h1>
  <p>FINAL TIME: <span id="victory-time">0</span></p>
  <p style="color:var(--accent)">EARNED CREDITS: <span id="earned-credits-win">0</span></p>
  <button class="btn" onclick="location.reload()">PLAY AGAIN</button>
</div>
<div id="settings">
  <h2 style="margin-top:0; border-bottom: 2px solid var(--accent); padding-bottom: 5px;">SYSTEM PREFERENCES</h2>
  <div class="settings-grid">
    <div class="settings-group">
        <label>Theme
            <select id="bg-select">
                <option value="dark">Dark</option>
                <option value="space">Space</option>
                <option value="grid">Grid</option>
                <option value="neon">Neon</option>
                <option value="sunset">Sunset</option>
            </select>
        </label>
        <label>Volume <input type="range" id="volume-slider" min="0" max="100" value="50"></label>
        <label>Screen Shake <input type="range" id="shake-slider" min="0" max="200" value="100"></label>
    </div>
<div class="settings-group">
    <label>Crosshair Color <input type="color" id="crosshair-color" value="#ffffff"></label>
    <label>Crosshair Size <input type="range" id="crosshair-size" min="10" max="50" value="24"></label>
    <label>UI Scale <input type="range" id="ui-scale" min="80" max="150" value="100"></label>
</div>

<div class="settings-group">
    <label>Show Crosshair <input type="checkbox" id="crosshair-toggle" checked /></label>
    <label>Auto-Reload <input type="checkbox" id="auto-reload-toggle" checked /></label>
    <label>Damage Numbers <input type="checkbox" id="damage-numbers-toggle" checked /></label>
</div>

<div class="settings-group">
    <label>Speedrun Timer <input type="checkbox" id="timer-toggle" /></label>
    <label>Player HP Bar <input type="checkbox" id="hp-toggle" checked /></label>
    <label>Enemy HP Bars <input type="checkbox" id="enemy-hp-toggle" checked /></label>
</div>

  </div>
  <div id="controls-settings" style="margin-top: 10px; padding-top: 15px; border-top: 1px solid #444;">
    <div style="color: var(--accent); font-size: 14px; margin-bottom: 12px; letter-spacing: 2px; font-weight: bold;">TACTICAL INPUTS (CLICK TO REBIND)</div>
    <div id="keybinds-list" style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;"></div>
  </div>
  <div class="settings-actions" style="margin-top: 20px;">
    <button class="btn" onclick="applySettings()" style="background: #222;">SAVE & APPLY</button>
    <button class="btn" onclick="leaveRun()" style="color: #ff4d4d;">LEAVE RUN</button>
    <button class="btn" onclick="closeSettings()">CLOSE</button>
  </div>
</div>
<canvas id="gameCanvas"></canvas>
<script>
require("./presence.js");
const SETTINGS = {
  theme: localStorage.getItem('yta_theme') || 'dark',
  crosshair: localStorage.getItem('yta_cross') !== 'false',
  timer: localStorage.getItem('yta_timer') === 'true',
  showHP: localStorage.getItem('yta_hp') !== 'false',
  showEnemyHP: localStorage.getItem('yta_enemy_hp') !== 'false',
  sounds: localStorage.getItem('yta_snd') !== 'false',
  autoReload: localStorage.getItem('yta_auto_reload') !== 'false',
  damageNumbers: localStorage.getItem('yta_dmg_nums') !== 'false',
  bloodEffects: localStorage.getItem('yta_blood') !== 'false', // New
  volume: parseInt(localStorage.getItem('yta_vol')) || 50,
  shake: parseInt(localStorage.getItem('yta_shake')) || 100,
  crossColor: localStorage.getItem('yta_cross_color') || '#ffffff',
  playerColor: localStorage.getItem('yta_player_color') || '#ffffff', // New
  crossSize: parseInt(localStorage.getItem('yta_cross_size')) || 24,
  uiScale: parseInt(localStorage.getItem('yta_ui_scale')) || 100
};


let KEYBINDS = JSON.parse(localStorage.getItem('yta_keybinds')) || {
    up: 'w', left: 'a', down: 's', right: 'd',
    dash: ' ', swap: 'q', reload: 'r', grenade: 'g', skill: 'f', pause: 'p'
};

const DIFF_SETTINGS = {
  very: { speedMult: 0.7, hpMult: 0.5, spawnRate: 140, bossMult: 0.8 },
  easy: { speedMult: 0.85, hpMult: 0.75, spawnRate: 120, bossMult: 1.2 },
  norm: { speedMult: 1.0, hpMult: 1.0, spawnRate: 90,  bossMult: 1.8 },
  hard: { speedMult: 1.3, hpMult: 1.5, spawnRate: 65,  bossMult: 2.5 },
  night:{ speedMult: 1.5, hpMult: 2.2, spawnRate: 45,  bossMult: 3.5 },
  insane:{ speedMult: 1.8, hpMult: 3.5, spawnRate: 32, bossMult: 5.0 }
};

const WEAPONS = {
  KNIFE: { name:'Knife', maxAmmo:Infinity, reloadTime:0, fireRate:400, damage:45, speed:15, life:8, radius: 70, isMelee: true, price: 0, ability: "BLADE WHIRL", cd: 5000 },
  PISTOL: { name:'Pistol', maxAmmo:12, reloadTime:800, fireRate:250, damage:18, speed:22, radius: 5, price: 0, ability: "FAN HAMMER", cd: 4000 },
  P90: { name:'P90', maxAmmo:50, reloadTime:1200, fireRate:85, damage:7, speed:20, radius: 4, secondary: 'PISTOL', price: 650, ability: "OVERDRIVE", cd: 8000 },
  UZI: { name:'Uzi', maxAmmo:32, reloadTime:1000, fireRate:45, damage:5, speed:24, radius: 3, secondary: 'PISTOL', price: 950, ability: "SPRAY & PRAY", cd: 6000 },
  BOW: { name:'Longbow', maxAmmo:1, reloadTime:1000, fireRate:100, damage:150, speed:38, radius: 6, secondary:'KNIFE', price: 1400, ability: "ARROW RAIN", cd: 9000 },
  ENERGY: { name:'Pulse Rifle', maxAmmo:Infinity, reloadTime:0, fireRate:70, damage:6, speed:38, radius: 4, secondary:'PISTOL', price: 2200, ability: "STATIC DISCHARGE", cd: 7000 },
  SHOTGUN: { name:'Shotgun', maxAmmo:8, reloadTime:1600, fireRate:550, damage:12, speed:18, radius: 3, pellets:8, spread:0.42, secondary:'PISTOL', price: 2800, ability: "DRAGON BREATH", cd: 6000 },
  BR: { name:'Battle Rifle', maxAmmo:24, reloadTime:1300, fireRate:320, damage:28, speed:32, radius: 5, secondary: 'PISTOL', price: 3500, ability: "BURST FIRE", cd: 4000 },
  REVOLVER: { name:'Magnum', maxAmmo:6, reloadTime:1400, fireRate:400, damage:85, speed:30, radius: 6, secondary:'KNIFE', price: 4200, ability: "DEAD EYE", cd: 10000 },
  CROSSBOW: { name:'Crossbow', maxAmmo:5, reloadTime:1800, fireRate:300, damage:110, speed:35, radius: 5, secondary:'KNIFE', price: 5500, ability: "TRIPLE BOLT", cd: 5000 },
  GL: { name:'Grenade Launcher', maxAmmo:6, reloadTime:2000, fireRate:750, damage:250, speed:14, radius: 8, secondary: 'KNIFE', price: 7500, ability: "CLUSTER BOMB", cd: 8000 },
  SNIPER: { name:'Sniper', maxAmmo:5, reloadTime:2200, fireRate:1400, damage:650, speed:60, radius: 8, pierce:4, secondary:'PISTOL', price: 9500, ability: "VOID PIERCE", cd: 9000 },
  DUAL: { name:'Dual Elites', maxAmmo:40, reloadTime:1100, fireRate:90, damage:16, speed:26, radius: 4, secondary: 'PISTOL', price: 11000, ability: "GUN KATA", cd: 7000 },
  FLAME: { name:'Flamethrower', maxAmmo:250, reloadTime:2200, fireRate:25, damage:4, speed:15, radius: 28, range:250, secondary:'KNIFE', price: 14000, ability: "INFERNO RING", cd: 8000 },
  SAW: { name:'Chainsaw', maxAmmo:Infinity, reloadTime:0, fireRate:35, damage:35, speed:10, life:5, isMelee: true, radius: 100, price: 18000, ability: "BLOODLUST", cd: 10000 },
  TESLA: { name:'Tesla Coil', maxAmmo:120, reloadTime:1800, fireRate:100, damage:22, speed:22, radius: 10, secondary: 'ENERGY', price: 22000, ability: "CHAIN LIGHTNING", cd: 9000 },
  SPEAR: { name:'Plasma Spear', maxAmmo:Infinity, reloadTime:0, fireRate:550, damage:800, speed:28, life:15, isMelee: true, radius: 180, price: 28000, ability: "THUNDERBOLT", cd: 5000 },
  RAILGUN: { name:'Railgun', maxAmmo:1, reloadTime:3800, fireRate:100, damage:2200, speed:70, radius: 14, pierce:10, secondary:'PISTOL', price: 35000, ability: "ORBITAL BEAM", cd: 15000 },
  ROCKET: { name:'RPG-7', maxAmmo:1, reloadTime:2800, fireRate:100, damage:1800, speed:18, radius: 14, secondary: 'PISTOL', price: 45000, ability: "NUKE", cd: 18000 },
  KATANA: { name:'Katana', maxAmmo:Infinity, reloadTime:0, fireRate:200, damage:1200, speed:24, life:12, isMelee: true, radius: 130, secondary: 'KNIFE', price: 55000, ability: "JUDGEMENT CUT", cd: 10000 },
  MINIGUN: { name:'Minigun', maxAmmo:400, reloadTime:3200, fireRate:20, damage:14, speed:26, radius: 4, moveSlow: 0.60, secondary:'PISTOL', price: 75000, ability: "RAMPAGE", cd: 14000 },
  PLASMA: { name:'Plasma Caster', maxAmmo:50, reloadTime:1800, fireRate:130, damage:350, speed:22, isPlasma: true, radius: 18, secondary: 'ENERGY', price: 95000, ability: "SINGULARITY", cd: 18000 },
  VOID: { name:'Void Cannon', maxAmmo:8, reloadTime:3500, fireRate:1800, damage:4500, speed:14, radius: 50, isPlasma: true, secondary: 'PLASMA', price: 150000, ability: "BLACK HOLE", cd: 25000 },
  ORB: { name:'Gravity Orb', maxAmmo:Infinity, reloadTime:0, fireRate:2500, damage:250, speed:16, radius: 40, isPlasma: true, secondary: 'PLASMA', price: 300000, ability: "EVENT HORIZON", cd: 30000 },
  SCYTHE: { name:'Death Scythe', maxAmmo:Infinity, reloadTime:0, fireRate:300, damage:8500, speed:20, life:15, isMelee: true, radius: 350, price: 1000000, ability: "SOUL REAP", cd: 8000 }
};

const PERK_POOL = [
    { id: 'dmg', name: 'High Velocity', desc: '+25% Global Damage', effect: () => player.mods.dmg *= 1.25 },
    { id: 'rate', name: 'Hair Trigger', desc: '+20% Fire Rate', effect: () => player.mods.rate *= 0.8 },
    { id: 'speed', name: 'Servo Boost', desc: '+15% Movement Speed', effect: () => player.mods.speed *= 1.15 },
    { id: 'hp', name: 'Bulkhead', desc: '+40 Max HP & Full Heal', effect: () => { player.maxHP += 40; player.hp = player.maxHP; } },
    { id: 'shield', name: 'Refractor', desc: '+25 Max Shield & Regen Speed', effect: () => { player.maxShield += 25; player.mods.shieldRegen *= 1.4; } },
    { id: 'vamp', name: 'Life Link', desc: 'Heal 3 HP per kill', effect: () => player.mods.vamp += 3 },
    { id: 'pierce', name: 'Tungsten Tip', desc: '+1 Pierce to all projectiles', effect: () => player.mods.pierce += 1 },
    { id: 'crit', name: 'Targeting Link', desc: '20% Chance for 3x Critical Damage', effect: () => player.mods.crit += 0.2 },
    { id: 'dash', name: 'Phase Shift', desc: '-35% Dash Cooldown', effect: () => abilityState.dash.max *= 0.65 },
    { id: 'skill', name: 'Core Flush', desc: '-25% Skill Cooldown', effect: () => abilityState.weaponAbility.max *= 0.75 },
    { id: 'grenade', name: 'Blast Pack', desc: '-40% Grenade Cooldown', effect: () => abilityState.grenade.max *= 0.6 },
    { id: 'ammo', name: 'Drum Mag', desc: '+50% Ammo Capacity', effect: () => { Object.keys(WEAPONS).forEach(k => { if(WEAPONS[k].maxAmmo !== Infinity) WEAPONS[k].maxAmmo = Math.floor(WEAPONS[k].maxAmmo * 1.5); }); } },
    { id: 'knock', name: 'Force Pulse', desc: 'Double weapon knockback', effect: () => player.mods.knockback += 5 },
    { id: 'xp', name: 'Learning AI', desc: '+30% XP Gain', effect: () => player.mods.xpMult *= 1.3 },
    { id: 'invuln', name: 'Plating Lock', desc: '+50% Invulnerability duration', effect: () => player.mods.invulnMult *= 1.5 }
];

const LEVEL_DATA = [
  { level: 1, enemies: ['normal'], bossName: 'THE SENTINEL', bossType: 'mini', waves: 10, enemiesPerWave: 15 },
  { level: 2, enemies: ['runner', 'tank'], bossName: 'THE CORE', bossType: 'mid', waves: 12, enemiesPerWave: 20 },
  { level: 3, enemies: ['phantom', 'tank'], bossName: 'THE HARBINGER', bossType: 'harbinger', waves: 15, enemiesPerWave: 25 },
  { level: 4, enemies: ['runner', 'tank', 'phantom', 'bomber'], bossName: 'THE OVERSEER', bossType: 'final', waves: 18, enemiesPerWave: 30 },
  { level: 5, enemies: ['phantom', 'bomber', 'shooter'], bossName: 'THE ARCHITECT', bossType: 'architect', waves: 20, enemiesPerWave: 35 },
  { level: 6, enemies: ['tank', 'bomber', 'shooter'], bossName: 'THE SINGULARITY', bossType: 'god', waves: 22, enemiesPerWave: 40 },
  { level: 7, enemies: ['phantom', 'shooter', 'bomber'], bossName: 'THE SPECTRE', bossType: 'harbinger', waves: 24, enemiesPerWave: 45 },
  { level: 8, enemies: ['tank', 'splitter', 'shooter'], bossName: 'THE COLOSSUS', bossType: 'final', waves: 26, enemiesPerWave: 50 },
  { level: 9, enemies: ['runner', 'phantom', 'bomber', 'shooter'], bossName: 'THE VOID WALKER', bossType: 'architect', waves: 28, enemiesPerWave: 55 },
  { level: 10, enemies: ['splitter', 'tank', 'bomber'], bossName: 'THE GOLIATH', bossType: 'god', waves: 30, enemiesPerWave: 60 },
  { level: 11, enemies: ['phantom', 'bomber', 'shooter', 'splitter'], bossName: 'THE OMEGA', bossType: 'final', waves: 32, enemiesPerWave: 65 },
  { level: 12, enemies: ['tank', 'phantom', 'runner', 'shooter'], bossName: 'THE ECLIPSE', bossType: 'architect', waves: 34, enemiesPerWave: 70 },
  { level: 13, enemies: ['bomber', 'shooter', 'phantom', 'splitter'], bossName: 'THE NEBULA', bossType: 'god', waves: 36, enemiesPerWave: 75 },
  { level: 14, enemies: ['tank', 'runner', 'bomber', 'phantom', 'shooter', 'splitter'], bossName: 'THE TITAN', bossType: 'final', waves: 38, enemiesPerWave: 85 },
  { level: 15, enemies: ['normal', 'runner', 'tank', 'phantom', 'bomber', 'shooter', 'splitter'], bossName: 'THE ASCENDED', bossType: 'god', waves: 45, enemiesPerWave: 100 }
];

function makeEnemy(x, y, isBoss = false, type = 'normal') {
  const d = DIFF_SETTINGS[difficulty]; 
  const levelScale = 1 + (currentLevelIdx * 0.45); // Increased scaling
  let radius = 20, speed = (1.3 + Math.random() * 1.3) * d.speedMult * levelScale, hp = 120 * d.hpMult * levelScale;

  if (type === 'runner') { speed *= 2.5; hp *= 0.6; radius = 14; }
  else if (type === 'tank') { speed *= 0.6; hp *= 10.0; radius = 40; }
  else if (type === 'phantom') { speed *= 2.1; hp *= 0.8; radius = 18; }
  else if (type === 'bomber') { speed *= 2.3; hp *= 0.5; radius = 16; }
  else if (type === 'shooter') { speed *= 0.9; hp *= 1.4; radius = 22; }
  else if (type === 'splitter') { speed *= 1.0; hp *= 3.5; radius = 34; }

  if (isBoss) {
    switch(type) {
        case 'mini': radius = 65; hp = 3500; break;
        case 'mid': radius = 95; hp = 12000; break;
        case 'harbinger': radius = 110; hp = 32000; break;
        case 'final': radius = 150; hp = 102000; break;
        case 'architect': radius = 170; hp = 220000; break;
        case 'god': radius = 220; hp = 750000; break;
        default: radius = 100; hp = 50000;
    }
    hp *= d.hpMult * d.bossMult * (1 + (currentLevelIdx * 0.15));
    speed = 1.2 * d.speedMult * (1 + (currentLevelIdx * 0.05));
  }

  return { 
    x, y, isBoss, type, radius, speed, hp, maxHp: hp, lastShoot: 0,
    state: 'IDLE',
    stateTimer: 0,
    phase: 1,
    dashVel: {x: 0, y: 0},
    specialPos: {x: 0, y: 0},
    dying: false
  };
}

const PERMANENT_UPGRADES = {
    // --- Core Stats ---
    hp: { name: "Nano-Plating", cost: 1000, step: 500, max: 10, bonus: 20, desc: "+20 Max HP" },
    shield: { name: "Aegis Core", cost: 1500, step: 750, max: 10, bonus: 15, desc: "+15 Max Shield" },
    speed: { name: "Synapse Boost", cost: 2000, step: 1000, max: 5, bonus: 0.1, desc: "+10% Movement Speed" },
    credits: { name: "Data Scraper", cost: 3000, step: 1500, max: 5, bonus: 0.2, desc: "+20% Credit Gain" },

    // --- Offensive Upgrades ---
    damage: { name: "High-Caliber Rounds", cost: 4000, step: 2000, max: 10, bonus: 0.05, desc: "+5% Global Damage" },
    fireRate: { name: "Rapid Trigger", cost: 4500, step: 2500, max: 8, bonus: 0.04, desc: "+4% Fire Rate" },
    critChance: { name: "Precision Optics", cost: 5000, step: 3000, max: 10, bonus: 0.03, desc: "+3% Crit Chance" },
    pierce: { name: "Tungsten Cores", cost: 8000, step: 5000, max: 3, bonus: 1, desc: "+1 Pierce Count" },
    knockback: { name: "Kinetic Impact", cost: 3000, step: 1500, max: 5, bonus: 2, desc: "+2 Knockback Force" },
    reloadSpeed: { name: "Fast Hands", cost: 3500, step: 1500, max: 10, bonus: 0.07, desc: "+7% Reload Speed" },

    // --- Ability Upgrades ---
    dashCD: { name: "Reflex Thrusters", cost: 4000, step: 2000, max: 5, bonus: 0.1, desc: "-10% Dash Cooldown" },
    dashDist: { name: "Long-Jump Servos", cost: 3000, step: 1500, max: 5, bonus: 0.15, desc: "+15% Dash Distance" },
    grenadeCD: { name: "Auto-Loader (G)", cost: 4000, step: 2000, max: 5, bonus: 0.1, desc: "-10% Grenade Cooldown" },
    grenadeDmg: { name: "High Explosives", cost: 5000, step: 2500, max: 10, bonus: 0.1, desc: "+10% Grenade Damage" },
    skillCD: { name: "Coolant Overclock", cost: 6000, step: 3000, max: 5, bonus: 0.08, desc: "-8% Skill Cooldown" },

    // --- Defensive & Utility ---
    vampire: { name: "Bio-Siphon", cost: 10000, step: 8000, max: 5, bonus: 1, desc: "+1 HP per Kill" },
    xpGain: { name: "Learning Matrix", cost: 2500, step: 1200, max: 10, bonus: 0.1, desc: "+10% XP Gain" },
    shieldRegen: { name: "Flux Capacitor", cost: 5000, step: 2500, max: 5, bonus: 0.25, desc: "+25% Shield Regen Speed" },
    invulnTime: { name: "Phase Shift Extender", cost: 7000, step: 4000, max: 5, bonus: 0.2, desc: "+20% I-Frame Duration" },
    ammoCap: { name: "Deep Pockets", cost: 3000, step: 1500, max: 10, bonus: 0.1, desc: "+10% Ammo Capacity" },
    pickupRange: { name: "Magnetic Pulse", cost: 2000, step: 1000, max: 5, bonus: 50, desc: "+50px Pickup Range" },
    healthRegen: { name: "Nano-Bots", cost: 12000, step: 10000, max: 3, bonus: 0.5, desc: "+0.5 HP Regen / sec" },
    startingAmmo: { name: "Full Magazine", cost: 2000, step: 1000, max: 5, bonus: 0.2, desc: "Start with +20% Ammo" },
    bossDmg: { name: "Giant Slayer", cost: 9000, step: 4500, max: 5, bonus: 0.1, desc: "+10% Damage to Bosses" }
};

let credits = parseInt(localStorage.getItem('yta_credits')) || 0;
let sessionEarned = 0;

// --- FIXED: WEAPON INITIALIZATION ---
let unlockedWeapons;
try {
    unlockedWeapons = JSON.parse(localStorage.getItem('yta_unlocked'));
} catch (e) {
    unlockedWeapons = null;
}

if (!unlockedWeapons || !Array.isArray(unlockedWeapons) || unlockedWeapons.length === 0) {
    unlockedWeapons = ['KNIFE', 'PISTOL', 'P90']; 
    localStorage.setItem('yta_unlocked', JSON.stringify(unlockedWeapons));
}


let upgradeLevels = JSON.parse(localStorage.getItem('yta_upgrades')) || {};

// Initialize missing keys to 0
Object.keys(PERMANENT_UPGRADES).forEach(key => {
    if (upgradeLevels[key] === undefined) upgradeLevels[key] = 0;
});

if (upgradeLevels.credits === undefined) upgradeLevels.credits = 0;

let isSandbox = false;
let selectedWeaponKey = null;

function saveEconomy() {
    localStorage.setItem('yta_credits', credits);
    localStorage.setItem('yta_unlocked', JSON.stringify(unlockedWeapons));
    localStorage.setItem('yta_upgrades', JSON.stringify(upgradeLevels));
    localStorage.setItem('yta_keybinds', JSON.stringify(KEYBINDS));
}

function toggleUpgradeMenu(show) {
    document.getElementById('upgrade-menu').style.display = show ? 'block' : 'none';
    document.getElementById('menu').style.display = show ? 'none' : 'block';
    if(show) renderUpgrades();
}

function toggleShop(show) {
    document.getElementById('shop-menu').style.display = show ? 'block' : 'none';
    document.getElementById('menu').style.display = show ? 'none' : 'block';
    if(show) renderShop();
}

function renderUpgrades() {
    // Update credits display at the top (matches renderShop)
    const creditsEl = document.getElementById('upgrade-credits-display');
    if (creditsEl) creditsEl.innerText = `CREDITS: ${credits}`;

    const list = document.getElementById('upgrade-list');
    list.innerHTML = '';

    Object.keys(PERMANENT_UPGRADES).forEach(key => {
        const up = PERMANENT_UPGRADES[key];
        const lvl = upgradeLevels[key] || 0;
        const cost = up.cost + (lvl * up.step);
        
        const card = document.createElement('div');
        card.className = 'upgrade-card'; // Uses existing CSS flex structure
        
        card.innerHTML = `
            <div>
                <div style="font-weight:bold; color:white;">
                    ${up.name} <span class="upgrade-lvl">LVL ${lvl}/${up.max}</span>
                </div>
                <div class="upgrade-info">${up.desc}</div>
            </div>
            <button class="btn" 
                style="width:140px; margin:0; border-color: var(--upgrade); color: var(--upgrade);" 
                onclick="buyUpgrade('${key}')" 
                ${lvl >= up.max || credits < cost ? 'disabled' : ''}>
                ${lvl >= up.max ? 'MAXED' : 'UPGRADE: ' + cost + ' CR'}
            </button>
        `;
        list.appendChild(card);
    });
}

function renderShop() {
    document.getElementById('shop-credits-display').innerText = `CREDITS: ${credits}`;
    const list = document.getElementById('shop-list');
    list.innerHTML = '';
    Object.keys(WEAPONS).forEach(key => {
        if (unlockedWeapons.includes(key)) return;
        const w = WEAPONS[key];
        const card = document.createElement('div');
        card.className = 'shop-card';
        card.innerHTML = `
            <div>
                <div style="font-weight:bold; color:white;">${w.name}</div>
                <div class="shop-info">DMG: ${w.damage} | FIRE RATE: ${w.fireRate}ms</div>
            </div>
            <button class="btn" style="width:140px; margin:0; border-color: var(--shop); color: var(--shop);" onclick="buyWeapon('${key}')" ${credits < w.price ? 'disabled' : ''}>
                BUY: ${w.price} CR
            </button>
        `;
        list.appendChild(card);
    });
    if (list.innerHTML === '') list.innerHTML = '<div style="color:#888; padding:20px;">ALL WEAPONS UNLOCKED</div>';
}

function buyWeapon(key) {
    const w = WEAPONS[key];
    if (credits >= w.price) {
        credits -= w.price;
        unlockedWeapons.push(key);
        saveEconomy();
        renderShop();
        updateMenuUI();
        playTone(1200, 0.2, 'sine', 0.05);
    }
}

function buyUpgrade(key) {
    const up = PERMANENT_UPGRADES[key];
    const lvl = upgradeLevels[key] || 0;
    const cost = up.cost + (lvl * up.step);
    if (credits >= cost && lvl < up.max) {
        credits -= cost;
        upgradeLevels[key] = lvl + 1;
        saveEconomy();
        renderUpgrades();
        updateMenuUI();
        playTone(1500, 0.2, 'sine', 0.05);
    }
}

function updateMenuUI() {
    const creditsDisplay = document.getElementById('credits-display');
    if (creditsDisplay) creditsDisplay.innerText = `CREDITS: ${credits}`;

    const grid = document.getElementById('weapon-buttons');
    if (grid) {
        grid.innerHTML = '';
        unlockedWeapons.forEach(key => {
            const w = WEAPONS[key];
            if (!w) return;
            const btn = document.createElement('button');
            btn.className = 'btn';
            if (key === selectedWeaponKey) btn.classList.add('selected');
            btn.innerText = w.name;
            btn.onclick = () => handleWeaponClick(key);
            grid.appendChild(btn);
        });
    }

    const sandWeaponSelect = document.getElementById('sandbox-weapon-select');
    if (sandWeaponSelect) {
        if (sandWeaponSelect.options.length === 0) {
            Object.keys(WEAPONS).forEach(key => {
                const opt = document.createElement('option');
                opt.value = key;
                opt.innerText = WEAPONS[key].name;
                sandWeaponSelect.appendChild(opt);
            });
        }
        sandWeaponSelect.value = currentWeapon;
    }
}

function handleWeaponClick(key) {
    selectedWeaponKey = key;
    document.getElementById('play-btn').style.display = 'block';
    document.getElementById('selected-weapon-text').innerText = "READY: " + WEAPONS[key].name;
    updateMenuUI();
    playTone(600, 0.1, 'sine', 0.05);
}

function changeWeapon(key) {
    if (isReloading) cancelReload();
    currentWeapon = key;
    currentMode = key;
    selectedWeaponKey = key; 
    if (weaponAmmo[currentWeapon] === undefined) {
        weaponAmmo[currentWeapon] = WEAPONS[currentWeapon].maxAmmo;
    }
    updateUI();
    playTone(800, 0.06, 'square', 0.02);
}

function calculatePayout() {
    if (isSandbox) return 0;
    const bonusMult = 1 + (upgradeLevels.credits * PERMANENT_UPGRADES.credits.bonus);
    const totalEarned = Math.floor((Math.floor(score / 15) + (currentLevelIdx * 500) + sessionEarned) * bonusMult);
    credits += totalEarned;
    saveEconomy();
    return totalEarned;
}

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const ui = document.getElementById('ui');
const menu = document.getElementById('menu');
const settingsEl = document.getElementById('settings');
const timerEl = document.getElementById('timer-container');
const scoreEl = document.getElementById('score');
const hudCreditsEl = document.getElementById('hud-credits');
const ammoEl = document.getElementById('ammo-count');
const ammoMaxEl = document.getElementById('ammo-max');
const hpFill = document.getElementById('hp-fill-bar');
const hpText = document.getElementById('hp-text');
const shieldFill = document.getElementById('shield-fill-bar');
const bossUi = document.getElementById('boss-ui');
const bossBar = document.getElementById('boss-bar-fill');
const bossName = document.getElementById('boss-name');
const comboUi = document.getElementById('combo-ui');
const comboCountEl = document.getElementById('combo-count');
const levelDisplay = document.getElementById('level-display');
const levelBanner = document.getElementById('level-banner');
const xpFill = document.getElementById('xp-fill');

let difficulty = 'norm';
let gameState = 'MENU';
let currentMode = 'P90';
let currentWeapon = 'P90';
let weaponAmmo = {}; 
let score = 0, combo = 0, comboTimer = 0, startTime = 0, frame = 0;
let keys = {}, mousePos = {x:0, y:0};
let isShooting=false, lastAttack=0, isReloading=false, reloadTimeout = null, reloadStartTime = 0, animationId = null, screenShake = 0;
let currentLevelIdx = 0, currentWave = 1, waveSpawnedCount = 0, levelBossSpawned = false, bossActive = false;

let player = { x:0, y:0, radius:18, speed:5.5, lunge:0, maxHP:100, hp:100, maxShield: 50, shield: 50, invuln: 0, xp: 0, nextXp: 1000, runLevel: 1, mods: {} };
let abilityState = { dash: { cooldown: 0, max: 2200 }, grenade: { cooldown: 0, max: 5500 }, weaponAbility: { cooldown: 0, max: 8000, active: false, duration: 4000 } };

const enemies = [], attacks = [], enemyAttacks = [], drops = [], damageTexts = [], particles = [];

const audioCtx = (window.AudioContext || window.webkitAudioContext) ? new (window.AudioContext || window.webkitAudioContext)() : null;
function playTone(freq=440, dur=0.05, type='sine', vol=0.02){
  if(!audioCtx || SETTINGS.volume <= 0) return;
  try {
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = type; o.frequency.value = freq; g.gain.value = vol * (SETTINGS.volume / 100);
    o.connect(g); g.connect(audioCtx.destination);
    o.start(); o.stop(audioCtx.currentTime+dur);
    g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime+dur);
  } catch(e) {}
}

function resize(){ canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
window.addEventListener('resize', resize); resize();

function createDamageNumber(x, y, amount, isCrit) {
    if (!SETTINGS.damageNumbers) return;
    damageTexts.push({
        x: x,
        y: y,
        text: Math.floor(amount),
        life: 45,
        vx: (Math.random() - 0.5) * 2,
        vy: -2.5,
        color: isCrit ? "#ECFF0C" : "#FFFFFF",
        size: isCrit ? 22 : 14
    });
}

function createParticle(x, y, color, count=5) {
    // If there are already 500+ particles, stop creating more to prevent crashing
    if (particles.length > 500) return;
    
    for(let i=0; i<count; i++) {
        particles.push({ 
            x, y, 
            vx: (Math.random()-0.5)*10, 
            vy: (Math.random()-0.5)*10, 
            life: 20 + Math.random()*20, 
            color 
        });
    }
}


function setDiff(d){ 
    difficulty=d; 
    document.querySelectorAll('.diff-btn').forEach(b=>b.classList.remove('active')); 
    const el=document.getElementById('diff-'+d); 
    if(el) el.classList.add('active'); 
    document.getElementById('difficulty-display').innerText = 'DIFFICULTY: ' + d.toUpperCase(); 
}

function updateUI(){
  const currentLevel = LEVEL_DATA[currentLevelIdx];
  document.getElementById('mode-display').innerText = currentWeapon;
  levelDisplay.innerText = isSandbox ? "SANDBOX" : "LVL " + currentLevel.level + (bossActive ? " [BOSS]" : " - WAVE " + currentWave + "/" + currentLevel.waves);
  const w = WEAPONS[currentWeapon];
  ammoEl.innerText = (w.maxAmmo === Infinity ? '∞' : Math.floor(weaponAmmo[currentWeapon]));
  scoreEl.innerText = Math.floor(score);
  hudCreditsEl.innerText = credits;
  document.getElementById('run-lvl').innerText = player.runLevel;
  hpFill.style.width = (Math.max(0, Math.min(1, player.hp / player.maxHP))*100) + '%';
  hpText.innerText = Math.ceil(player.hp) + '/' + Math.ceil(player.maxHP);
  shieldFill.style.width = (Math.max(0, Math.min(1, player.shield / player.maxShield))*100) + '%';
  xpFill.style.width = ((player.xp / player.nextXp) * 100) + '%';
  document.getElementById('skill-name').innerText = w.ability || "NONE";
  abilityState.weaponAbility.max = (w.cd || 8000) * (player.mods.skillRate || 1);
  document.getElementById('cd-ability').style.width = ((1 - Math.max(0, abilityState.weaponAbility.cooldown) / abilityState.weaponAbility.max)*100) + '%';
  document.getElementById('cd-dash').style.width = ((1 - Math.max(0, abilityState.dash.cooldown) / abilityState.dash.max)*100) + '%';
  document.getElementById('cd-grenade').style.width = ((1 - Math.max(0, abilityState.grenade.cooldown) / abilityState.grenade.max)*100) + '%';
  comboUi.style.display = combo > 1 ? 'block' : 'none';
  if (combo > 1) comboCountEl.innerText = combo;
  document.getElementById('secondary-text').innerText = w.secondary || (currentWeapon === 'KNIFE' ? 'Pistol' : 'N/A');
  // Change this line in updateUI
  const maxAmmoVal = w.maxAmmo === Infinity ? '∞' : Math.floor(w.maxAmmo * (player.mods?.ammoMult || 1));
  ammoMaxEl.innerText = maxAmmoVal;

}

function syncSettingsToUI() {
    document.getElementById('bg-select').value = SETTINGS.theme;
    document.getElementById('volume-slider').value = SETTINGS.volume;
    document.getElementById('shake-slider').value = SETTINGS.shake;
    document.getElementById('crosshair-color').value = SETTINGS.crossColor;
    document.getElementById('crosshair-size').value = SETTINGS.crossSize;
    document.getElementById('ui-scale').value = SETTINGS.uiScale;
    document.getElementById('crosshair-toggle').checked = SETTINGS.crosshair;
    document.getElementById('timer-toggle').checked = SETTINGS.timer;
    document.getElementById('hp-toggle').checked = SETTINGS.showHP;
    document.getElementById('enemy-hp-toggle').checked = SETTINGS.showEnemyHP;
    document.getElementById('auto-reload-toggle').checked = SETTINGS.autoReload;
    document.getElementById('damage-numbers-toggle').checked = SETTINGS.damageNumbers;
    updateKeybindsUI();
}

let rebindTarget = null;
function updateKeybindsUI() {
    const list = document.getElementById('keybinds-list');
    list.innerHTML = '';
    Object.keys(KEYBINDS).forEach(action => {
        const row = document.createElement('div');
        row.className = 'keybind-row';
        row.innerHTML = `<span>${action.toUpperCase()}</span><div class="keybind-btn ${rebindTarget === action ? 'waiting' : ''}" onclick="startRebind('${action}')">${rebindTarget === action ? '???' : (KEYBINDS[action] === ' ' ? 'SPACE' : KEYBINDS[action].toUpperCase())}</div>`;
        list.appendChild(row);
    });
}

function startRebind(action) { rebindTarget = action; updateKeybindsUI(); }

function openSettings() {
  if (gameState === 'PLAYING') { gameState = 'PAUSED'; cancelAnimationFrame(animationId); }
  syncSettingsToUI(); settingsEl.style.display = 'block';
}

function closeSettings() {
  settingsEl.style.display = 'none'; rebindTarget = null;
  if (gameState === 'PAUSED') { gameState = 'PLAYING'; startTime = Date.now() - (parseFloat(timerEl.innerText) * 1000); animate(); }
}

function applySettings(){
  SETTINGS.theme = document.getElementById('bg-select').value;
  SETTINGS.volume = parseInt(document.getElementById('volume-slider').value);
  SETTINGS.shake = parseInt(document.getElementById('shake-slider').value);
  SETTINGS.crossColor = document.getElementById('crosshair-color').value;
  SETTINGS.crossSize = parseInt(document.getElementById('crosshair-size').value);
  SETTINGS.uiScale = parseInt(document.getElementById('ui-scale').value);
  SETTINGS.crosshair = document.getElementById('crosshair-toggle').checked;
  SETTINGS.timer = document.getElementById('timer-toggle').checked;
  SETTINGS.showHP = document.getElementById('hp-toggle').checked;
  SETTINGS.showEnemyHP = document.getElementById('enemy-hp-toggle').checked;
  SETTINGS.autoReload = document.getElementById('auto-reload-toggle').checked;
  SETTINGS.damageNumbers = document.getElementById('damage-numbers-toggle').checked;
  saveEconomy(); applyTheme(SETTINGS.theme);
  const cross = document.getElementById('crosshair');
  cross.style.display = SETTINGS.crosshair ? 'block' : 'none';
  cross.style.borderColor = SETTINGS.crossColor;
  cross.style.width = cross.style.height = SETTINGS.crossSize + 'px';
  timerEl.style.display = SETTINGS.timer ? 'block' : 'none';
  document.getElementById('player-hp').style.display = SETTINGS.showHP ? 'block' : 'none';
  const uiEl = document.getElementById('ui');
  uiEl.style.transform = `scale(${SETTINGS.uiScale/100})`; uiEl.style.transformOrigin = 'top left';
  closeSettings();
}

function applyTheme(name){
  const body = document.body; 
  body.style.backgroundImage = 'none';
  body.style.backgroundAttachment = 'fixed'; // Prevents scrolling issues

  const themes = {
    dark: "#050505",
    space: "radial-gradient(circle at center, #1b2735 0%, #090a0f 100%)",
    grid: "linear-gradient(rgba(255,255,255,0.03) 1px, transparent 1px), linear-gradient(90deg, rgba(255,255,255,0.03) 1px, transparent 1px)",
    neon: "linear-gradient(135deg, #0d001a 0%, #00050a 100%)",
    sunset: "linear-gradient(180deg, #2c1a32 0%, #5f1b1b 100%)",
    cyberpunk: "linear-gradient(135deg, #001a1a 0%, #1a001a 100%)",
    abyssal: "radial-gradient(circle, #000814 0%, #000000 100%)",
    forest: "linear-gradient(135deg, #0a1a0a 0%, #050505 100%)"
  };

  body.style.background = themes[name] || themes.dark;
  if(name === 'grid') body.style.backgroundSize = "50px 50px";
}


function leaveRun(){
  gameState = 'MENU'; if (animationId) cancelAnimationFrame(animationId);
  menu.style.display = 'block'; ui.style.display = settingsEl.style.display = document.getElementById('sandbox-ui').style.display = bossUi.style.display = levelBanner.style.display = 'none';
  selectedWeaponKey = null; isSandbox = false; document.getElementById('play-btn').style.display = 'none';
  document.getElementById('selected-weapon-text').innerText = "SELECT A WEAPON TO BEGIN"; updateMenuUI();
}

window.addEventListener('keydown', e => {
    const k = e.key.toLowerCase();
    if (rebindTarget) { KEYBINDS[rebindTarget] = k; rebindTarget = null; updateKeybindsUI(); saveEconomy(); return; }
    keys[k] = true;
    if (k === KEYBINDS.pause) { if (settingsEl.style.display === 'block') closeSettings(); else openSettings(); }
    if (e.key === 'Escape') closeSettings();
    if (gameState !== 'PLAYING') return;
    if (k === KEYBINDS.reload) startReload();
    if (k === KEYBINDS.swap) swapWeapon();
    if (k === KEYBINDS.skill) tryUseAbility();
    if (k === KEYBINDS.dash) tryDash();
    if (k === KEYBINDS.grenade) tryGrenade();
});

window.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });
window.addEventListener('wheel', () => { if (gameState === 'PLAYING') swapWeapon(); });
window.addEventListener('mousemove', e => { 
    mousePos.x = e.clientX; mousePos.y = e.clientY; 
    const cross = document.getElementById('crosshair'); if(cross) { cross.style.left = e.clientX + 'px'; cross.style.top = e.clientY + 'px'; }
});
window.addEventListener('mousedown', (e) => {
    if (gameState === 'PLAYING' && isSandbox && e.shiftKey) {
        const type = document.getElementById('sandbox-enemy-select').value;
        enemies.push(makeEnemy(mousePos.x, mousePos.y, ['mini', 'mid', 'final'].includes(type), type));
        playTone(400, 0.1, 'sine', 0.05); return;
    }
    isShooting = true;
});
window.addEventListener('mouseup', () => isShooting = false);

function swapWeapon() {
    if (isReloading) cancelReload();
    const w = WEAPONS[currentWeapon];
    currentWeapon = w.secondary || (currentWeapon === 'KNIFE' ? 'PISTOL' : currentMode);
    if (weaponAmmo[currentWeapon] === undefined) weaponAmmo[currentWeapon] = WEAPONS[currentWeapon].maxAmmo;
    updateUI(); playTone(800, 0.06, 'square', 0.02);
}

function startReload(){
    const w = WEAPONS[currentWeapon];
    if(isReloading || weaponAmmo[currentWeapon] >= w.maxAmmo || w.maxAmmo === Infinity || window.Sapphire?.getState()?.noReload) return;
    isReloading = true; reloadStartTime = Date.now(); document.getElementById('reload-msg').style.display = 'block';
    reloadTimeout = setTimeout(() => { 
        weaponAmmo[currentWeapon] = w.maxAmmo; 
        lastAttack = 0; // RAILGUN/BOW FIX
        isReloading = false; 
        document.getElementById('reload-msg').style.display = 'none'; 
        playTone(1200, 0.1, 'sine', 0.02); 
    }, w.reloadTime);
}

function cancelReload(){ isReloading = false; clearTimeout(reloadTimeout); document.getElementById('reload-msg').style.display = 'none'; }

function tryDash() {
    if (abilityState.dash.cooldown > 0 && !window.Sapphire?.getState()?.unlimitedDash) return;
    player.lunge = 38 * player.mods.lungeMult; player.invuln = 30 * player.mods.invulnMult; abilityState.dash.cooldown = abilityState.dash.max; playTone(600, 0.1, 'sine', 0.04);
}

function tryGrenade() {
    if (abilityState.grenade.cooldown > 0 && !window.Sapphire?.getState()?.infiniteGrenades) return;
    const angle = Math.atan2(mousePos.y - player.y, mousePos.x - player.x);
    attacks.push({ x: player.x, y: player.y, vx: Math.cos(angle) * 14, vy: Math.sin(angle) * 14, life: 55, damage: 0, radius: 10, type: 'GRENADE_LOB' });
    abilityState.grenade.cooldown = abilityState.grenade.max; playTone(200, 0.1, 'square', 0.03);
}

function tryUseAbility(){
  if(abilityState.weaponAbility.cooldown > 0 || gameState !== 'PLAYING') return;
  
  const w = WEAPONS[currentWeapon]; 
  abilityState.weaponAbility.cooldown = (w.cd || 8000) * (player.mods.skillRate || 1);
  const angle = Math.atan2(mousePos.y - player.y, mousePos.x - player.x);

  switch(currentWeapon) {
    case 'KNIFE': 
        attacks.push({ x:player.x, y:player.y, vx:0, vy:0, life:25, damage:w.damage * 3, type:'MELEE', radius: 300 }); 
        player.invuln = 25; 
        break;
    case 'PISTOL': 
        for(let i=0; i<12; i++) { 
            const a = (i/12) * Math.PI * 2; 
            attacks.push({ x:player.x, y:player.y, vx:Math.cos(a)*25, vy:Math.sin(a)*25, life:40, damage:w.damage * 4, radius: 8, type:'PISTOL' }); 
        } 
        break;
    case 'P90': 
        abilityState.weaponAbility.active = true; 
        setTimeout(() => { if(gameState === 'PLAYING') abilityState.weaponAbility.active = false; }, 5000); 
        break;
    case 'UZI':
        for(let i=0; i<25; i++) {
            setTimeout(() => {
                if(gameState !== 'PLAYING') return;
                const s = angle + (Math.random()-0.5)*0.6;
                attacks.push({ x:player.x, y:player.y, vx:Math.cos(s)*35, vy:Math.sin(s)*35, life:30, damage:w.damage * 2, radius:3, type:'UZI' });
            }, i * 30);
        }
        break;
    case 'BOW': 
        for(let i=0; i<20; i++) { 
            attacks.push({ x:Math.random()*canvas.width, y:-50, vx:0, vy:20, life:100, damage:w.damage * 1.5, radius: 10, type:'SNIPER' }); 
        } 
        break;
    case 'ENERGY': 
        attacks.push({ x:player.x, y:player.y, vx:0, vy:0, life:60, damage:w.damage * 0.8, type:'STATIC', radius: 400 }); 
        break;
    case 'SHOTGUN': 
        player.lunge = 70; 
        attacks.push({ x:player.x, y:player.y, vx:Math.cos(angle)*15, vy:Math.sin(angle)*15, life:30, damage:w.damage * 5, radius: 150, type:'EXPLOSION' }); 
        break;
    case 'BR':
        for(let i=0; i<5; i++) {
            setTimeout(() => {
                if(gameState !== 'PLAYING') return;
                attacks.push({ x:player.x, y:player.y, vx:Math.cos(angle)*45, vy:Math.sin(angle)*45, life:50, damage:w.damage * 2, radius:7, type:'BR' });
            }, i * 80);
        }
        break;
    case 'REVOLVER':
        attacks.push({ x:player.x, y:player.y, vx:Math.cos(angle)*70, vy:Math.sin(angle)*70, life:100, damage:w.damage * 10, type:'SNIPER', radius: 14, pierce: 5 });
        break;
    case 'CROSSBOW':
        for(let i=-2; i<=2; i++) {
            const a = angle + (i * 0.15);
            attacks.push({ x:player.x, y:player.y, vx:Math.cos(a)*40, vy:Math.sin(a)*40, life:60, damage:w.damage * 2.5, radius:8, type:'CROSSBOW' });
        }
        break;
    case 'GL':
        for(let i=0; i<3; i++) {
            const a = angle + (i-1)*0.2;
            attacks.push({ x:player.x, y:player.y, vx:Math.cos(a)*15, vy:Math.sin(a)*15, life:50, damage:0, radius:12, type:'GRENADE_LOB' });
        }
        break;
    case 'SNIPER': 
        attacks.push({ x:player.x, y:player.y, vx:Math.cos(angle)*100, vy:Math.sin(angle)*100, life:200, damage:w.damage * 15, type:'SNIPER', radius: 20, pierce: 100 }); 
        break;
    case 'DUAL':
        for(let i=0; i<40; i++) {
            const a = Math.random() * Math.PI * 2;
            attacks.push({ x:player.x, y:player.y, vx:Math.cos(a)*30, vy:Math.sin(a)*30, life:45, damage:w.damage * 2, radius:5, type:'PISTOL' });
        }
        break;
    case 'FLAME': 
        for(let i=0; i<50; i++) { 
            const a = (i/50) * Math.PI * 2; 
            attacks.push({ x:player.x, y:player.y, vx:Math.cos(a)*10, vy:Math.sin(a)*10, life:60, damage:w.damage * 1.5, radius: 45, type:'FLAME' }); 
        } 
        break;
    case 'SAW':
        player.lunge = 60;
        attacks.push({ x:player.x, y:player.y, vx:0, vy:0, life:50, damage:w.damage * 3, type:'MELEE', radius: 250 });
        break;
    case 'TESLA':
        enemies.forEach(en => {
            if(Math.hypot(en.x - player.x, en.y - player.y) < 700) {
                en.hp -= w.damage * 10;
                attacks.push({ x:player.x, y:player.y, vx:(en.x-player.x)/10, vy:(en.y-player.y)/10, life:15, damage:0, type:'STATIC', radius:5 });
            }
        });
        break;
    case 'SPEAR':
        player.lunge = 150;
        player.invuln = 40;
        attacks.push({ x:player.x, y:player.y, vx:Math.cos(angle)*5, vy:Math.sin(angle)*5, life:40, damage:w.damage * 4, type:'STATIC', radius: 300 });
        break;
    case 'RAILGUN':
        screenShake = 60;
        attacks.push({ x:player.x, y:player.y, vx:Math.cos(angle)*120, vy:Math.sin(angle)*120, life:200, damage:w.damage * 20, type:'SNIPER', radius: 50, pierce: 200 });
        break;
    case 'ROCKET':
        screenShake = 100;
        attacks.push({ x:player.x, y:player.y, vx:Math.cos(angle)*10, vy:Math.sin(angle)*10, life:1, damage:w.damage * 10, radius: 800, type:'EXPLOSION' });
        break;
    case 'KATANA': 
        player.lunge = 200; 
        player.invuln = 60; 
        attacks.push({ x:player.x, y:player.y, vx:0, vy:0, life:40, damage:w.damage * 8, type:'MELEE', radius: 500 }); 
        break;
    case 'MINIGUN':
        abilityState.weaponAbility.active = true;
        setTimeout(() => { if(gameState === 'PLAYING') abilityState.weaponAbility.active = false; }, 8000);
        break;
    case 'PLASMA': 
        attacks.push({ x:mousePos.x, y:mousePos.y, vx:0, vy:0, life:200, maxLife:200, damage:w.damage * 0.5, type:'SINGULARITY', radius: 300 }); 
        break;
    case 'VOID':
        attacks.push({ x:mousePos.x, y:mousePos.y, vx:0, vy:0, life:250, maxLife:250, damage:w.damage * 0.8, type:'SINGULARITY', radius: 500 });
        break;
    case 'ORB':
        attacks.push({ x:player.x, y:player.y, vx:0, vy:0, life:300, maxLife:300, damage:w.damage, type:'SINGULARITY', radius: 1000 });
        break;
    case 'SCYTHE':
        attacks.push({ x:player.x, y:player.y, vx:0, vy:0, life:50, damage:w.damage * 10, type:'MELEE', radius: 800 });
        player.hp = Math.min(player.maxHP, player.hp + (player.maxHP * 0.2));
        break;
  }
}
function makeEnemy(x,y,isBoss=false,type='normal'){
  const d = DIFF_SETTINGS[difficulty]; const levelScale = 1 + (currentLevelIdx * 0.25);
  let radius = 20, speed = (1.3 + Math.random() * 1.3) * d.speedMult * levelScale, hp = 100 * d.hpMult * levelScale;
  if(type === 'runner') { speed *= 2.3; hp *= 0.55; radius = 14; }
  else if(type === 'tank') { speed *= 0.55; hp *= 8.0; radius = 38; }
  else if(type === 'phantom') { speed *= 1.9; hp *= 0.75; radius = 18; }
  else if(type === 'bomber') { speed *= 2.0; hp *= 0.4; radius = 16; }
  else if(type === 'shooter') { speed *= 0.8; hp *= 1.2; radius = 22; }
  else if(type === 'splitter') { speed *= 0.9; hp *= 3.0; radius = 32; }
  if(isBoss){ radius = (type==='mini'?65:(type==='mid'?95:150)); hp = (type==='mini'?3500:(type==='mid'?12000:85000)) * d.hpMult * d.bossMult; speed = 1.2 * d.speedMult * levelScale; }
  return { x, y, isBoss, type, radius, speed, hp, maxHp: hp, lastShoot: 0 };
}

function startSandbox() {
    selectedWeaponKey = 'P90'; startGame(); isSandbox = true; document.getElementById('sandbox-ui').style.display = 'block';
    player.maxHP = player.hp = player.maxShield = player.shield = 999999;
}

function startGame() {
  if (!selectedWeaponKey) return;
  if (animationId) cancelAnimationFrame(animationId);
  const mode = selectedWeaponKey; currentMode = currentWeapon = mode;
  weaponAmmo = {}; 
  
  // Apply Permanent Upgrades to Mods
  player.mods = { 
      dmg: 1 + (upgradeLevels.damage * PERMANENT_UPGRADES.damage.bonus), 
      rate: 1 - (upgradeLevels.fireRate * PERMANENT_UPGRADES.fireRate.bonus), 
      speed: 1 + (upgradeLevels.speed * PERMANENT_UPGRADES.speed.bonus), 
      vamp: upgradeLevels.vampire * PERMANENT_UPGRADES.vampire.bonus, 
      pierce: upgradeLevels.pierce * PERMANENT_UPGRADES.pierce.bonus, 
      shieldRegen: 1 + (upgradeLevels.shieldRegen * PERMANENT_UPGRADES.shieldRegen.bonus), 
      crit: upgradeLevels.critChance * PERMANENT_UPGRADES.critChance.bonus, 
      knockback: upgradeLevels.knockback * PERMANENT_UPGRADES.knockback.bonus, 
      xpMult: 1 + (upgradeLevels.xpGain * PERMANENT_UPGRADES.xpGain.bonus), 
      invulnMult: 1 + (upgradeLevels.invulnTime * PERMANENT_UPGRADES.invulnTime.bonus), 
      lungeMult: 1 + (upgradeLevels.dashDist * PERMANENT_UPGRADES.dashDist.bonus),
      ammoMult: 1 + (upgradeLevels.ammoCap * PERMANENT_UPGRADES.ammoCap.bonus),
      skillRate: 1 - (upgradeLevels.skillCD * PERMANENT_UPGRADES.skillCD.bonus),
      bossDmg: 1 + (upgradeLevels.bossDmg * PERMANENT_UPGRADES.bossDmg.bonus)
  };

  // Apply Cooldown Modifiers
  abilityState.dash.max = 2200 * (1 - (upgradeLevels.dashCD * PERMANENT_UPGRADES.dashCD.bonus));
  abilityState.grenade.max = 5500 * (1 - (upgradeLevels.grenadeCD * PERMANENT_UPGRADES.grenadeCD.bonus));

  // HP and Shield Calculation
  player.maxHP = (100 + (upgradeLevels.hp * PERMANENT_UPGRADES.hp.bonus)) * DIFF_SETTINGS[difficulty].hpMult;
  player.hp = player.maxHP; 
  player.maxShield = 50 + (upgradeLevels.shield * PERMANENT_UPGRADES.shield.bonus);
  player.shield = player.maxShield; 

  // Weapon Ammo Initialization
  Object.keys(WEAPONS).forEach(k => {
      let base = WEAPONS[k].maxAmmo;
      if (base !== Infinity) {
          let boosted = Math.floor(base * player.mods.ammoMult);
          weaponAmmo[k] = boosted * (1 + (upgradeLevels.startingAmmo * 0.2));
      } else {
          weaponAmmo[k] = Infinity;
      }
  });  
  player.maxHP = (100 + ((upgradeLevels.hp || 0) * PERMANENT_UPGRADES.hp.bonus)) * DIFF_SETTINGS[difficulty].hpMult;
  player.hp = player.maxHP; player.maxShield = 50 + ((upgradeLevels.shield || 0) * PERMANENT_UPGRADES.shield.bonus);
  player.shield = player.maxShield; player.xp = 0; player.nextXp = 1000; player.runLevel = 1;
  resize(); player.x = canvas.width/2; player.y = canvas.height/2; player.invuln = 0; player.lunge = 0;
  score = combo = comboTimer = sessionEarned = currentLevelIdx = waveSpawnedCount = 0; currentWave = 1; levelBossSpawned = bossActive = false;
  startTime = Date.now(); gameState = 'PLAYING'; menu.style.display = 'none'; ui.style.display = 'block';
  enemies.length=attacks.length=enemyAttacks.length=drops.length=damageTexts.length=particles.length=0;
  applyTheme(SETTINGS.theme); applySettings(); showLevelBanner("LEVEL 1 - WAVE 1"); animate();
}

function showPerkMenu() {
    gameState = 'PAUSED';
    const menu = document.getElementById('perk-menu');
    const container = document.getElementById('perk-choices');
    document.getElementById('perk-level-num').innerText = player.runLevel;
    container.innerHTML = '';
    const choices = [...PERK_POOL].sort(() => 0.5 - Math.random()).slice(0, 3);
    choices.forEach(perk => {
        const card = document.createElement('div');
        card.className = 'perk-card';
        card.innerHTML = `<div class="perk-name">${perk.name}</div><div class="perk-desc">${perk.desc}</div>`;
        card.onclick = () => {
            perk.effect();
            menu.style.display = 'none';
            gameState = 'PLAYING';
            startTime = Date.now() - (parseFloat(timerEl.innerText) * 1000);
            animate();
            playTone(1000, 0.2, 'sine', 0.05);
        };
        container.appendChild(card);
    });
    menu.style.display = 'block';
    playTone(600, 0.4, 'sine', 0.05);
}

function spawnBoss(name,type){
  bossActive = true; levelBossSpawned = true; bossName.innerText = name; bossUi.style.display = 'block'; bossBar.style.width = '100%';
  enemies.push(makeEnemy(canvas.width/2, -150, true, type)); showLevelBanner("BOSS: " + name); playTone(120,0.2, 'sine', 0.06);
}

function showLevelBanner(text) { levelBanner.innerText = text; levelBanner.style.display = 'block'; setTimeout(() => { levelBanner.style.display = 'none'; }, 3000); }

function animate(){
  if(gameState !== 'PLAYING') return;
  ctx.setTransform(1,0,0,1,0,0); ctx.clearRect(0,0,canvas.width,canvas.height);
  if (screenShake > 0) { const m = screenShake * (SETTINGS.shake / 100); ctx.setTransform(1,0,0,1, (Math.random()-0.5)*m, (Math.random()-0.5)*m); screenShake *= 0.9; }
  ctx.fillStyle = 'rgba(5,5,5,0.45)'; ctx.fillRect(-100, -100, canvas.width+200, canvas.height+200);
  const now = Date.now(); if(SETTINGS.timer) timerEl.innerText = ((now - startTime)/1000).toFixed(2);
  
  abilityState.dash.cooldown = Math.max(0, abilityState.dash.cooldown - 16);
  abilityState.grenade.cooldown = Math.max(0, abilityState.grenade.cooldown - 16);
  abilityState.weaponAbility.cooldown = Math.max(0, abilityState.weaponAbility.cooldown - 16);
  
  if (comboTimer > 0) comboTimer--; else combo = 0;
  if (frame % 60 === 0 && player.shield < player.maxShield) player.shield = Math.min(player.maxShield, player.shield + (1 * (player.mods?.shieldRegen || 1)));
  updateUI();

  if (bossActive) {
      const boss = enemies.find(e => e.isBoss);
      if (boss) bossBar.style.width = Math.max(0, (boss.hp / boss.maxHp) * 100) + '%';
      else { bossUi.style.display = 'none'; bossActive = false; }
  }

  player.speed = 2.0 * DIFF_SETTINGS[difficulty].speedMult * (WEAPONS[currentWeapon].moveSlow || 1.8) * (1 + ((upgradeLevels.speed || 0) * 0.1)) * (player.mods?.speed || 1);
  if (player.invuln > 0) player.invuln--;
  
  let vx=0, vy=0;
  if(keys[KEYBINDS.up]) vy -= 1; if(keys[KEYBINDS.down]) vy += 1; if(keys[KEYBINDS.left]) vx -= 1; if(keys[KEYBINDS.right]) vx += 1;
  let mag = Math.hypot(vx, vy); if (mag > 0) { vx = (vx / mag) * (player.speed + player.lunge); vy = (vy / mag) * (player.speed + player.lunge); }
  player.x += vx; player.y += vy; player.lunge *= 0.88;
  
  // MOD COMPATIBILITY: Noclip
  if (!window.Sapphire?.getState()?.noclip) {
    player.x = Math.max(player.radius, Math.min(canvas.width - player.radius, player.x));
    player.y = Math.max(player.radius, Math.min(canvas.height - player.radius, player.y));
  }

  for(let i=particles.length-1; i>=0; i--) {
      const p = particles[i]; p.x += p.vx; p.y += p.vy; p.life--;
      ctx.fillStyle = p.color; ctx.globalAlpha = p.life/40; ctx.beginPath(); ctx.arc(p.x, p.y, 2, 0, Math.PI*2); ctx.fill();
      ctx.globalAlpha = 1.0; if(p.life <= 0) particles.splice(i, 1);
  }
for (let i = damageTexts.length - 1; i >= 0; i--) {
    const dt = damageTexts[i];
    dt.x += dt.vx;
    dt.y += dt.vy;
    dt.life--;

    ctx.save();
    ctx.globalAlpha = dt.life / 45;
    ctx.fillStyle = dt.color;
    ctx.font = `bold ${dt.size}px "Courier New"`;
    ctx.textAlign = "center";
    ctx.fillText(dt.text, dt.x, dt.y);
    ctx.restore();

    if (dt.life <= 0) damageTexts.splice(i, 1);
}
  ctx.fillStyle = player.invuln > 0 ? (frame % 4 < 2 ? '#ECFF0C' : '#fff') : SETTINGS.playerColor;
  ctx.beginPath(); 
  ctx.arc(player.x, player.y, player.radius, 0, Math.PI*2); 
  ctx.fill();

  if (player.shield > 0) { ctx.strokeStyle = `rgba(0, 204, 255, ${0.3 + Math.sin(frame/5)*0.2})`; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(player.x, player.y, player.radius + 5, 0, Math.PI*2); ctx.stroke(); }
  
  const ai = document.getElementById('sandbox-ai-toggle')?.checked ?? true;
  for (let i = enemies.length-1; i >= 0; i--) {
    const en = enemies[i];
    if (en.hp <= 0) { handleEnemyDeath(i, en); continue; }
    const ang = Math.atan2(player.y - en.y, player.x - en.x);
    const dist = Math.hypot(player.x - en.x, player.y - en.y);

    if (ai || !isSandbox) {
        if (en.isBoss) {
            // Initialize Boss State properties if missing
            if (en.state === undefined) {
                en.state = 'MOVING';
                en.stateTimer = 0;
                en.phase = 1;
                en.dashVel = {x:0, y:0};
                en.specialPos = {x:0, y:0};
            }

            en.stateTimer--;

            // Phase 2 Transition (50% HP)
            if (en.hp < en.maxHp * 0.5 && en.phase === 1) {
                en.phase = 2;
                en.speed *= 1.4;
                createParticle(en.x, en.y, "#ff0000", 40);
                playTone(100, 0.3, 'sawtooth', 0.05);
            }

            // State Switcher
            if (en.stateTimer <= 0) {
                const rng = Math.random();
                if (rng < 0.25) {
                    en.state = 'DASHING';
                    en.stateTimer = 30;
                    en.dashVel = { x: Math.cos(ang) * 22, y: Math.sin(ang) * 22 };
                } else if (rng < 0.6) {
                    en.state = 'ATTACKING';
                    en.stateTimer = 100;
                } else if (rng < 0.75 && en.phase === 2) {
                    en.state = 'TELEPORTING';
                    en.stateTimer = 30;
                } else {
                    en.state = 'MOVING';
                    en.stateTimer = 60;
                }
            }

            // State Execution
            switch (en.state) {
                case 'MOVING':
                    en.x += Math.cos(ang) * en.speed;
                    en.y += Math.sin(ang) * en.speed;
                    break;
                case 'DASHING':
                    en.x += en.dashVel.x;
                    en.y += en.dashVel.y;
                    if (frame % 2 === 0) createParticle(en.x, en.y, "rgba(255,255,255,0.4)", 1);
                    break;
                case 'TELEPORTING':
                    if (en.stateTimer === 15) {
                        createParticle(en.x, en.y, "#00ffff", 25);
                        en.x = player.x + (Math.random() - 0.5) * 600;
                        en.y = player.y + (Math.random() - 0.5) * 600;
                        createParticle(en.x, en.y, "#00ffff", 25);
                        playTone(900, 0.05, 'sine', 0.02);
                    }
                    break;
                case 'ATTACKING':
                    switch(en.type) {
                        case 'mini': // THE SENTINEL: Rapid Fire
                            if (en.stateTimer % 6 === 0) enemyAttacks.push({ x: en.x, y: en.y, vx: Math.cos(ang)*10, vy: Math.sin(ang)*10, life: 120 });
                            break;
                        case 'mid': // THE CORE: Gravity Pull + Pulse
                            player.x += (en.x - player.x) * 0.015;
                            player.y += (en.y - player.y) * 0.015;
                            if (en.stateTimer % 20 === 0) {
                                for(let j=0; j<12; j++){
                                    const a = (j/12) * Math.PI * 2;
                                    enemyAttacks.push({ x: en.x, y: en.y, vx: Math.cos(a)*6, vy: Math.sin(a)*6, life: 150 });
                                }
                            }
                            break;
                        case 'harbinger': // THE HARBINGER: Spiral Barrage
                            const s = (en.stateTimer * 0.2);
                            enemyAttacks.push({ x: en.x, y: en.y, vx: Math.cos(s)*8, vy: Math.sin(s)*8, life: 140 });
                            enemyAttacks.push({ x: en.x, y: en.y, vx: Math.cos(s + Math.PI)*8, vy: Math.sin(s + Math.PI)*8, life: 140 });
                            break;
                        case 'final': // THE OVERSEER: Orbital Strike
                            if (en.stateTimer === 80) en.specialPos = {x: player.x, y: player.y};
                            ctx.strokeStyle = "red"; ctx.lineWidth = 2;
                            ctx.strokeRect(en.specialPos.x-50, en.specialPos.y-50, 100, 100);
                            if (en.stateTimer === 1) {
                                attacks.push({ x: en.specialPos.x, y: en.specialPos.y, vx:0, vy:0, life:15, damage:500, radius: 140, type:'EXPLOSION' });
                                playTone(150, 0.2, 'square', 0.04);
                            }
                            break;
                        case 'god': // THE ASCENDED: Judgement Cut
                            if (en.stateTimer % 3 === 0) {
                                const rx = player.x + (Math.random()-0.5)*400;
                                const ry = player.y + (Math.random()-0.5)*400;
                                ctx.strokeStyle = "white"; ctx.beginPath();
                                ctx.moveTo(rx-40, ry-40); ctx.lineTo(rx+40, ry+40); ctx.stroke();
                                if (Math.hypot(player.x - rx, player.y - ry) < 45) player.hp -= 4;
                            }
                            break;
                    }
                    break;
            }
        } else {
            // Regular AI
            if (en.type === 'shooter') {
                if (dist > 350) { en.x += Math.cos(ang) * en.speed; en.y += Math.sin(ang) * en.speed; }
                else if (dist < 250) { en.x -= Math.cos(ang) * en.speed; en.y -= Math.sin(ang) * en.speed; }
                if (now - en.lastShoot > 2000) { enemyAttacks.push({ x: en.x, y: en.y, vx: Math.cos(ang)*8, vy: Math.sin(ang)*8, life: 100 }); en.lastShoot = now; }
            } else { en.x += Math.cos(ang) * en.speed; en.y += Math.sin(ang) * en.speed; }
        }
    }

    ctx.save(); if(en.type === 'phantom') ctx.globalAlpha = 0.3 + Math.sin(frame/10)*0.2;
    ctx.fillStyle = en.isBoss ? '#ff0044' : (en.type === 'runner' ? '#ecff0c' : (en.type === 'tank' ? '#555' : (en.type === 'bomber' ? '#ff0000' : '#ff8800')));
    ctx.beginPath(); ctx.arc(en.x, en.y, en.radius, 0, Math.PI*2); ctx.fill();
    if(SETTINGS.showEnemyHP && en.hp < en.maxHp && !en.isBoss) {
        ctx.fillStyle = '#222'; ctx.fillRect(en.x - 15, en.y - en.radius - 12, 30, 4);
        ctx.fillStyle = '#ff4444'; ctx.fillRect(en.x - 15, en.y - en.radius - 12, 30 * (en.hp / en.maxHp), 4);
    }
    ctx.restore();

    if(player.invuln <= 0 && Math.hypot(en.x - player.x, en.y - player.y) < player.radius + en.radius - 5){
      let dmg = (en.isBoss ? 1.5 : (en.type === 'tank' ? 0.8 : 0.5));
      if (player.shield > 0) player.shield -= dmg; else player.hp -= dmg;
      if(player.hp <= 0) { gameState = 'GAMEOVER'; document.getElementById('game-over').style.display='block'; document.getElementById('final-score').innerText = Math.floor(score); document.getElementById('earned-credits-death').innerText = calculatePayout(); break; }
    }
  }

  for(let i=enemyAttacks.length-1; i>=0; i--) {
      const ea = enemyAttacks[i]; ea.x += ea.vx; ea.y += ea.vy; ea.life--;
      ctx.fillStyle = "#ff00ff"; ctx.beginPath(); ctx.arc(ea.x, ea.y, 6, 0, Math.PI*2); ctx.fill();
      if(Math.hypot(ea.x - player.x, ea.y - player.y) < player.radius + 6 && player.invuln <= 0) { if (player.shield > 0) player.shield -= 15; else player.hp -= 15; enemyAttacks.splice(i, 1); screenShake = 15; continue; }
      if(ea.life <= 0) enemyAttacks.splice(i, 1);
  }

  if(!isSandbox && !bossActive && !levelBossSpawned) {
    const l = LEVEL_DATA[currentLevelIdx];
    if (currentWave <= l.waves) {
        if (waveSpawnedCount < l.enemiesPerWave) {
            if (frame % Math.floor(Math.max(15, DIFF_SETTINGS[difficulty].spawnRate - (currentLevelIdx * 10)) / 1.5) === 0) {
                let rx, ry; do { rx = Math.random() * canvas.width; ry = Math.random() * canvas.height; if(Math.random() < 0.5) rx = (Math.random() < 0.5 ? -60 : canvas.width + 60); else ry = (Math.random() < 0.5 ? -60 : canvas.height + 60); } while (Math.hypot(rx - player.x, ry - player.y) < 300);
                enemies.push(makeEnemy(rx, ry, false, l.enemies[Math.floor(Math.random() * l.enemies.length)])); waveSpawnedCount++;
            }
        } else if (enemies.length === 0) { currentWave++; waveSpawnedCount = 0; if (currentWave <= l.waves) showLevelBanner("WAVE " + currentWave); }
    } else spawnBoss(l.bossName, l.bossType);
  }

  for(let i=drops.length-1; i>=0; i--){
      const d = drops[i]; ctx.fillStyle = d.type === 'health' ? '#ff4d4d' : (d.type === 'ammo' ? '#00ffff' : '#ff00ff'); ctx.fillRect(d.x-10, d.y-10, 20, 20);
      if(Math.hypot(player.x - d.x, player.y - d.y) < player.radius + 15){ if(d.type === 'health') player.hp = Math.min(player.maxHP, player.hp + 35); else if(d.type === 'ammo') weaponAmmo[currentWeapon] = Math.min(WEAPONS[currentWeapon].maxAmmo, (weaponAmmo[currentWeapon]||0) + (WEAPONS[currentWeapon].maxAmmo * 0.4)); else if(d.type === 'powerup') { player.invuln = 120; screenShake = 5; } drops.splice(i, 1); }
  }

  if(isShooting && !isReloading){
    const w = WEAPONS[currentWeapon]; let r = (abilityState.weaponAbility.active ? w.fireRate * 0.4 : w.fireRate) * (player.mods?.rate || 1);
    if(now - lastAttack > r){
      if (Math.floor(weaponAmmo[currentWeapon]) >= 1 || w.maxAmmo === Infinity || window.Sapphire?.getState()?.infiniteAmmo) {
          const a = Math.atan2(mousePos.y - player.y, mousePos.x - player.x);
          const p = (w.pierce || 0) + (player.mods?.pierce || 0);
          if(w.isMelee) attacks.push({ x:player.x, y:player.y, vx:Math.cos(a)*w.speed, vy:Math.sin(a)*w.speed, life:w.life, damage:w.damage, type:'MELEE', radius: w.radius });
          else if(currentWeapon === 'SHOTGUN'){ for(let p_idx=0; p_idx<w.pellets; p_idx++){ const s = a + (Math.random()-0.5)*w.spread; attacks.push({ x:player.x, y:player.y, vx:Math.cos(s)*w.speed, vy:Math.sin(s)*w.speed, life:45, damage:w.damage, type:'SHOTGUN', radius: w.radius }); } }
          else if(currentWeapon === 'FLAME'){ attacks.push({ x:player.x, y:player.y, vx:Math.cos(a)*w.speed, vy:Math.sin(a)*w.speed, life:25, damage:w.damage, type:'FLAME', radius: w.radius }); }
          else if(w.isPlasma) attacks.push({ x:player.x, y:player.y, vx:Math.cos(a)*w.speed, vy:Math.sin(a)*w.speed, life:100, damage:w.damage, type:'PLASMA', radius: w.radius });
          else attacks.push({ x:player.x, y:player.y, vx:Math.cos(a)*w.speed, vy:Math.sin(a)*w.speed, life:150, damage:w.damage, type:currentWeapon, radius: w.radius, pierce: p });
          
          // MOD COMPATIBILITY: Infinite Ammo
          if (w.maxAmmo !== Infinity && !window.Sapphire?.getState()?.infiniteAmmo) weaponAmmo[currentWeapon]--; 
          
          lastAttack = now; playTone(w.name === 'Sniper' ? 180 : 1000, 0.03, 'sine', 0.01);
      } else if (SETTINGS.autoReload && !isReloading) startReload();
    }
  }

  for(let i=attacks.length-1; i>=0; i--){
    const a = attacks[i];
    a.x += a.vx; a.y += a.vy; a.life--; 

    if(!a.life || a.life <= 0) {
      if (a.type === 'GRENADE_LOB') { 
        for(let e=0; e<24; e++){ const ang = (e/24) * Math.PI * 2; attacks.push({ x:a.x, y:a.y, vx:Math.cos(ang)*6, vy:Math.sin(ang)*6, life:25, damage:500, radius: 70, type:'EXPLOSION' }); } 
      }
      attacks.splice(i, 1); continue; 
    }

    if(a.type === 'SINGULARITY') {
      for (let j = enemies.length - 1; j >= 0; j--) {
        const en = enemies[j];
        if (!en || en.dying) continue;
        const dist = Math.hypot(a.x - en.x, a.y - en.y);
        let currentRadius = a.radius * (1 - (a.life / a.maxLife));
        if(dist < currentRadius) {
          en.x += (a.x - en.x) * 0.05; en.y += (a.y - en.y) * 0.05;
          en.hp -= a.damage; if(en.hp <= 0) handleEnemyDeath(j, en);
        }
      }
      ctx.save(); ctx.fillStyle = `rgba(100, 0, 255, ${0.2 + Math.random()*0.3})`; ctx.beginPath();
      ctx.arc(a.x, a.y, Math.max(0.1, a.radius * (1 - (a.life / a.maxLife))), 0, Math.PI*2); ctx.fill(); ctx.restore();
      continue; 
    }
    
    ctx.save();
    if(a.type === 'FLAME') { ctx.fillStyle = `rgba(255, ${Math.random()*200}, 0, ${a.life/25})`; ctx.beginPath(); ctx.arc(a.x, a.y, Math.max(1, 10 + (25-a.life)), 0, Math.PI*2); ctx.fill(); }
    else if (a.type === 'STATIC') { ctx.strokeStyle = `rgba(0, 255, 255, ${a.life/60})`; ctx.beginPath(); ctx.arc(a.x, a.y, a.radius, 0, Math.PI*2); ctx.stroke(); }
    else if (a.type === 'EXPLOSION') { ctx.fillStyle = `rgba(255, 120, 0, ${a.life/25})`; ctx.beginPath(); ctx.arc(a.x, a.y, Math.max(1, a.radius - a.life*2), 0, Math.PI*2); ctx.fill(); }
    else if (a.type === 'MELEE') { 
        ctx.strokeStyle = '#fff'; ctx.lineWidth = 4; ctx.beginPath(); 
        const ang = Math.atan2(mousePos.y - player.y, mousePos.x - player.x);
        ctx.arc(player.x, player.y, a.radius, ang - 0.8, ang + 0.8); ctx.stroke(); 
    }
    else { 
        ctx.fillStyle = (a.type === 'SNIPER' || a.type === 'RAILGUN') ? '#00ffff' : '#fff'; 
        ctx.beginPath(); ctx.moveTo(a.x, a.y); ctx.lineTo(a.x - a.vx * 0.6, a.y - a.vy * 0.6); 
        ctx.lineWidth = a.radius; ctx.strokeStyle = ctx.fillStyle; ctx.stroke(); 
    }
    ctx.restore();

    // --- CORRECTED ATTACK COLLISION LOOP ---
    for(let j=enemies.length-1; j>=0; j--){
      const en = enemies[j];
      if(!en || en.dying) continue;

      let collisionDist = (a.type === 'MELEE') ? Math.hypot(player.x - en.x, player.y - en.y) : Math.hypot(a.x - en.x, a.y - en.y);
      
      if(collisionDist < en.radius + a.radius){
        if (['GRENADE_LOB', 'STATIC'].includes(a.type)) continue;

        // 1. Calculate Damage and Crits
        const isCrit = Math.random() < (player.mods?.crit || 0);
        let dmg = (a.damage * (player.mods?.dmg || 1) * (isCrit ? 3 : 1));

        // MOD COMPATIBILITY: One-Hit Kill
        if (window.Sapphire?.getState()?.oneHitKill) dmg = en.maxHp + 999;

        // 2. Apply Damage
        en.hp = Math.max(0, en.hp - dmg);
        
        // 3. Trigger Damage Numbers and Particles
        createDamageNumber(en.x, en.y, dmg, isCrit); 
        createParticle(en.x, en.y, "#fff", 3);

        // 4. Handle Pierce / Projectile Destruction
        if(!['FLAME', 'EXPLOSION', 'MELEE', 'PLASMA'].includes(a.type)){ 
            if(a.pierce > 0) {
                a.pierce--; 
            } else { 
                attacks.splice(i, 1); 
                break; 
            } 
        }

        // 5. Check for Death
        if(en.hp <= 0) handleEnemyDeath(j, en);
        break; 
      }
    }
  }

  // --- DRAW FLOATING DAMAGE NUMBERS (OUTSIDE THE LOOPS) ---
  for (let i = damageTexts.length - 1; i >= 0; i--) {
      const dt = damageTexts[i];
      dt.x += dt.vx;
      dt.y += dt.vy;
      dt.life--;

      ctx.save();
      ctx.globalAlpha = dt.life / 45;
      ctx.fillStyle = dt.color;
      ctx.font = `bold ${dt.size}px "Courier New"`;
      ctx.textAlign = "center";
      ctx.fillText(dt.text, dt.x, dt.y);
      ctx.restore();

      if (dt.life <= 0) damageTexts.splice(i, 1);
  }

  frame++; 
  animationId = requestAnimationFrame(animate);
}


function handleEnemyDeath(index, en) {
    if (index === -1 || !en || en.dying) return; 
    en.dying = true;
    
    // Blood Effect Logic
    if (SETTINGS.bloodEffects) {
        const bloodColors = ["#8a0303", "#610202", "#b30000", "#4d0000"];
        const count = en.isBoss ? 40 : 12;
        for(let i=0; i<count; i++) {
            particles.push({ 
                x: en.x, y: en.y, 
                vx: (Math.random()-0.5)*12, 
                vy: (Math.random()-0.5)*12, 
                life: 30 + Math.random()*30, 
                color: bloodColors[Math.floor(Math.random()*bloodColors.length)] 
            });
        }
    } else {
        createParticle(en.x, en.y, "red", en.isBoss ? 20 : 8);
    }
    
    if (en.type === 'splitter') { 
        for(let k=0; k<3; k++) enemies.push(makeEnemy(en.x + (Math.random()-0.5)*20, en.y + (Math.random()-0.5)*20, false, 'runner')); 
    }    createParticle(en.x, en.y, "red", en.isBoss ? 20 : 8);
    if (en.type === 'splitter') { for(let k=0; k<3; k++) enemies.push(makeEnemy(en.x + (Math.random()-0.5)*20, en.y + (Math.random()-0.5)*20, false, 'runner')); }
    if (!isSandbox) {
        combo++; comboTimer = 200; score += 100; 
        player.xp += 50 * (player.mods?.xpMult || 1);
        player.hp = Math.min(player.maxHP, player.hp + (player.mods?.vamp || 0));
        if (player.xp >= player.nextXp) { player.runLevel++; player.xp = 0; player.nextXp *= 1.25; showPerkMenu(); }
        if (combo % 10 === 0) { credits += Math.floor(combo * 5 * (1 + (upgradeLevels.credits * 0.2))); saveEconomy(); }
        if (Math.random() < 0.05) drops.push({x:en.x, y:en.y, type: 'health'}); 
        if (Math.random() < 0.2) drops.push({x:en.x, y:en.y, type: 'ammo'});
    }
    if(en.isBoss) {
        bossActive = false; bossUi.style.display = 'none'; currentLevelIdx++;
        if(currentLevelIdx >= LEVEL_DATA.length) {
            gameState = 'VICTORY'; document.getElementById('victory').style.display = 'block';
            document.getElementById('earned-credits-win').innerText = calculatePayout();
        } else {
            currentWave = 1; levelBossSpawned = false;
            showLevelBanner("LEVEL " + (currentLevelIdx + 1) + " INITIATED");
        }
    }
    enemies.splice(index, 1);
}


applyTheme(SETTINGS.theme); syncSettingsToUI(); updateMenuUI();
const ic = document.getElementById('crosshair'); ic.style.display = SETTINGS.crosshair ? 'block' : 'none'; ic.style.borderColor = SETTINGS.crossColor; ic.style.width = ic.style.height = SETTINGS.crossSize + 'px';
const iu = document.getElementById('ui'); iu.style.transform = `scale(${SETTINGS.uiScale/100})`; iu.style.transformOrigin = 'top left';
timerEl.style.display = SETTINGS.timer ? 'block' : 'none'; document.getElementById('player-hp').style.display = SETTINGS.showHP ? 'block' : 'none';

// --- APOLLONGORILLA'S DEV TOOLS ---
let typedBuffer = "";
let godModeActive = false;

window.addEventListener('keydown', (e) => {
    if (rebindTarget) return; 
    typedBuffer += e.key.toLowerCase();
    if (typedBuffer.length > 6) typedBuffer = typedBuffer.slice(-6);
    if (typedBuffer === "secret") {
        document.getElementById('dev-menu').style.display = 'block';
        typedBuffer = "";
        playTone(600, 0.1, 'square', 0.1);
    }
});

function toggleGodMode() {
    godModeActive = !godModeActive;
    const btn = document.getElementById('god-mode-btn');

    if (godModeActive) {
        player.maxHP = player.hp = 999999;
        player.maxShield = player.shield = 999999;
        btn.innerText = "GOD MODE: ON";
        btn.style.backgroundColor = "rgba(255,0,0,0.3)";
        playTone(800, 0.1, 'sine', 0.05);
    } else {
        const d = DIFF_SETTINGS[difficulty] || DIFF_SETTINGS.norm;
        player.maxHP = (100 + ((upgradeLevels.hp || 0) * 20)) * d.hpMult;
        player.hp = player.maxHP;
        player.maxShield = 50 + ((upgradeLevels.shield || 0) * 15);
        player.shield = player.maxShield;
        
        btn.innerText = "GOD MODE: OFF";
        btn.style.backgroundColor = "transparent";
        playTone(400, 0.1, 'sine', 0.05);
    }
    if(typeof updateUI === 'function') updateUI();
}

function clearAllGameData() {
    if (confirm("APOLLONGORILLA: Are you sure you want to wipe all progress? This cannot be undone.")) {
        localStorage.clear();
        location.reload(); 
    }
}

// ==========================================
// SAPPHIRE MOD HOOKS (Compatibility Bridge)
// ==========================================
window.SapphireHooks = {
  setSpeedMultiplier: (v) => { 
      if(player.mods) player.mods.speed = v; 
  },
  setHealthInfinite: (v) => { 
      godModeActive = v; 
  },
  setAmmoInfinite: (v) => { 
      if(v && currentWeapon) weaponAmmo[currentWeapon] = WEAPONS[currentWeapon].maxAmmo;
  },
  setNoclip: (v) => {
      // Logic handled directly in the boundary check of animate()
  },
  onToggle: (key, val, state) => {
    if (key === 'godMode') godModeActive = val;
  },
  onTick: (state, dt) => {
    if (!player) return;
    if (state.godMode) player.hp = player.maxHP;
    if (state.infiniteAmmo && currentWeapon) weaponAmmo[currentWeapon] = WEAPONS[currentWeapon].maxAmmo;
    if (state.autoHeal && player.hp < player.maxHP) player.hp += 0.05;
    if (state.unlimitedDash) abilityState.dash.cooldown = 0;
  }
};

</script>

<!-- DISCORD RPC -->
<script>
  (function() {
    try {
      const RPC = require('discord-rpc');
      const clientId = '1469648752795979926'; 
      const client = new RPC.Client({ transport: 'ipc' });
      const startTimestamp = new Date();
      async function setActivity() {
        if (!client) return;
        client.setActivity({
          details: 'Playing Tactical Ascension',
          state: 'In Game',
          startTimestamp,
          largeImageKey: 'game_logo', 
          largeImageText: 'Tactical Ascension',
          instance: false,
        }).catch(err => {});
      }
      client.on('ready', () => {
        setActivity();
        setInterval(setActivity, 15000);
      });
      client.login({ clientId }).catch(err => {});
    } catch (err) {}
  })();
</script>

<!-- LOAD MOD FILE -->
<script src="sapphire.js"></script>

</body>
</html>
